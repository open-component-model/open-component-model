# Agents Guide — Open Component Model (OCM)

This document contains accumulated knowledge about the OCM repository for any LLM or AI agent working with this codebase.

## Repository Overview

OCM is a multi-module Go monorepo implementing the Open Component Model specification. It consists of three main areas:

- **bindings/go/** — 23+ independent Go library modules (the core libraries)
- **cli/** — The `ocm` CLI tool built with Cobra
- **kubernetes/controller/** — A controller-runtime-based Kubernetes operator

All modules use **Go 1.25.5**. The build system uses **Task** (not Make). There are no Makefiles.

## Agent Behavior Rules

- Be concise. Use simple sentences. Technical jargon is fine.
- Do NOT overexplain basic concepts. Assume the user is technically proficient.
- Avoid flattering, corporate, or marketing language. Maintain a neutral viewpoint.
- Avoid vague or generic claims not substantiated by context.
- Avoid commenting on each and every line. Keep comments to a minimum.
- You are expected to be an expert Go developer fluent in Kubernetes and its ecosystem.
- Follow idiomatic Go guidelines at all times.

## Code Style Rules

- Do NOT add comments on lines you are adding unless the logic is non-obvious.
- Follow idiomatic Go guidelines.
- Be concise. Use simple sentences. Technical jargon is fine.
- Assume the reader/user is technically proficient — do not overexplain basics.
- Avoid flattering, corporate, or marketing language. Neutral viewpoint only.
- Avoid vague or generic claims not substantiated by context.
- In tests, always use `t.Context()` instead of `context.Background()` or `context.TODO()`.

## Code Review Rules

### No Cross-Module Pollution
- PRs must not mix changes across multiple Go modules.
- The project contains 23+ independent modules in `bindings/go/`.
- Each PR should focus on a single module unless there's a clear dependency relationship.

### Follow Package Structure and Order
- Changes must align with the architecture and organization of the target package.
- Respect the established package hierarchy and dependencies.
- Maintain consistency with existing patterns in the package.

### Runtime Type System Validation
- Verify correct usage of the runtime type system (from `bindings/go/runtime/`).
- Ensure proper type registration and usage.
- Validate type conversions and runtime checks.

### Controller Performance
- When modifying `kubernetes/controller/`, ensure no performance regressions.
- Pay special attention to operations handling large numbers of objects.
- Consider: watch/list efficiency, reconciliation loop performance, memory usage, caching strategies.

## Global Conventions

### Build System

```bash
task test              # Run all unit tests
task test/integration  # Run integration tests (requires Docker)
task build             # Build CLI and controller
task generate          # Run all code generators
task tidy              # go mod tidy across all modules
task init/go.work      # Initialize Go workspace
```

The root `Taskfile.yml` includes module-specific taskfiles. Each module under `bindings/go/` has its own `Taskfile.yml` that reuses `reuse.Taskfile.yml` for test tasks.

### Import Order (gci enforced)

```go
import (
    "context"
    "fmt"

    _ "embed"

    "github.com/spf13/cobra"

    "ocm.software/open-component-model/bindings/go/runtime"
)
```

Order: standard library → blank imports → dot imports → third-party → OCM modules.

### Error Handling

```go
return fmt.Errorf("unable to open file: %w", err)
return errors.Join(ErrUnknown, fmt.Errorf("error: %w", err))
```

Use `errors.Is()` for sentinel checks. No complex error hierarchies.

### Sentinel Errors

```go
var ErrNotFound = errors.New("credentials not found")
```

### Commit Convention (enforced by CI)

```
type(scope): subject

feat(cli): add new command
fix(repository): handle nil pointer
chore(deps): update dependencies
```

Types: `feat`, `fix`, `chore`, `docs`, `test`, `perf`. Breaking changes use `!`: `feat(api)!: remove deprecated method`.

### Code Generation

Three generators exist:
1. **ocmtypegen** — Generates `GetType()/SetType()` methods
2. **jsonschemagen** — Generates JSON schemas
3. **deepcopy-gen** — Generates DeepCopy methods (v0.35.0)

Markers:
```go
// +ocm:typegen=true
// +ocm:jsonschema-gen=true
// +k8s:deepcopy-gen=true
```

Generated files are prefixed `zz_generated.*` with build tag `//go:build !ignore_autogenerated`. Always run `task generate` after adding or modifying markers.

### Linting

- Tool: golangci-lint v2.8.0
- Config: `golangci.yml` at repo root (CI uses `.github/config/golangci.yml`)
- Line length: 120, max function length: 110 lines / 60 statements, max cyclomatic complexity: 15
- Test files are exempt from complexity/length checks
- Generated code, `third_party/`, `builtin/`, `examples/` are excluded

```bash
golangci-lint run --config=.github/config/golangci.yml ./...
```

### Module Structure

- 26+ independent Go modules in monorepo
- Internal imports: `ocm.software/open-component-model/bindings/go/...`
- Integration tests have separate `go.mod` files
- Lockstep MAJOR/MINOR versions, independent PATCH
- PRs must not mix changes across multiple Go modules

### Runtime Type System

The foundation of OCM. Every typed object has `runtime.Type` (Name + Version).

```go
type MyType struct {
    Type runtime.Type `json:"type"`
}
func (t *MyType) GetType() runtime.Type  { return t.Type }
func (t *MyType) SetType(typ runtime.Type) { t.Type = typ }
```

Types are registered in `runtime.Scheme` — a thread-safe registry mapping `Type` → `reflect.Type`. The `Typed` interface requires `GetType()`, `SetType()`, and `DeepCopyTyped()`.

### CI Pipeline

- Smart module detection: CI discovers Go modules dynamically and filters based on changed files
- Tests only run for affected modules on PRs; full suite on main
- Pipeline: conventional commit validation → auto-labeling → module discovery → lint → unit tests → integration tests → CodeQL → generation verification
- Multi-arch builds for CLI and controller (linux/darwin, amd64/arm64)

---

## bindings/go/

### Structure

23 independent modules:

| Module | Purpose |
|--------|---------|
| `runtime/` | Core type system (Scheme, Type, Typed interface) |
| `blob/` | Binary blob handling |
| `cel/` | Common Expression Language bindings |
| `configuration/` | Configuration types |
| `constructor/` | Constructor implementation |
| `credentials/` | Credential management |
| `ctf/` | Component Transport Format |
| `dag/` | Directed Acyclic Graph utilities |
| `descriptor/` | Three sub-modules: normalisation, runtime, v2 |
| `generator/` | Code generators (ocmtypegen, jsonschemagen) |
| `helm/` | Helm integration |
| `input/` | Three sub-modules: dir, file, utf8 |
| `oci/` | OCI implementation + integration tests |
| `plugin/` | Plugin system |
| `repository/` | Repository layer |
| `rsa/` | RSA signing |
| `signing/` | Signing utilities |
| `transform/` | Transformation utilities |

### Testing

**Framework**: testify only (`require` and `mock`). No Ginkgo in bindings.

**Pattern**: `r := require.New(t)` at the start of every test function.

**Style**: Table-driven tests with `t.Run()` subtests are the dominant pattern.

```go
tests := []struct {
    input    string
    expected Type
    wantErr  bool
}{...}
for _, tt := range tests {
    t.Run(tt.input, func(t *testing.T) {
        r := require.New(t)
        // ...
    })
}
```

**Mocks**: Uses `testify/mock`:
```go
type MockReadOnlyBlob struct {
    mock.Mock
}
```

**Test data**: Embedded via `//go:embed testdata`. Conformance tests use `input.yaml`, `expected.json`, `README.md`.

**Running tests**:
```bash
cd bindings/go/<module>
task test
```

Or from root: `task test` runs all modules.

---

## cli/

### Structure

```
cli/
├── main.go              # Entry point, delegates to cmd.Execute()
├── cmd/
│   ├── cmd.go           # Root cobra command, registers all subcommands
│   ├── add/             # add component-version
│   ├── get/             # get component/resource
│   ├── download/        # download plugin/resource
│   ├── verify/          # verify component-version
│   ├── sign/            # sign component-version
│   ├── transfer/        # transfer component-version
│   ├── describe/        # describe types
│   ├── generate/        # generate docs
│   ├── plugins/         # plugins get/list
│   ├── configuration/   # config management
│   ├── setup/           # setup hooks
│   ├── version/         # version info
│   └── internal/test/   # Test helper (OCM() function)
├── integration/         # Integration tests (separate go.mod, testcontainers)
└── internal/            # Context, flags, repository, reference parsing
```

### CLI Flags

- `--config` — Configuration file
- `--temp-folder` — Custom temp directory
- `--plugin-directory` — Plugin path (default: `$HOME/.config/ocm/plugins`)
- `--working-directory` — Resource loading directory
- Logging flags via `log.RegisterLoggingFlags()`

### Building

```bash
cd cli
task build              # Builds to tmp/bin/ocm
./tmp/bin/ocm version
```

Multi-arch: `task build/multiarch` cross-compiles for windows/linux/darwin on amd64/arm64.

Version injection via ldflags: `-X ocm.software/open-component-model/cli/cmd/version.BuildVersion`.

### Testing

**Framework**: testify/require.

**Test helper** (`cmd/internal/test/test.go`):
```go
test.OCM(
    test.WithArgs("get", "component-version", "..."),
    test.WithOutput(&buf),
    test.WithErrorOutput(&errBuf),
    test.WithLogFormat("json"),
)
```

The `OCM()` function executes CLI commands programmatically with an options builder pattern. Default log format is JSON for testability.

**Unit tests**: Alongside source in `cmd/` directories. Skip integration tests pattern: `SKIP_PATTERN: 'Integration'`.

```bash
cd cli
task test
```

**Integration tests** (`cli/integration/`):
- Separate `go.mod` with `replace` directive pointing to parent CLI module
- Uses testcontainers for Docker-based OCI registries
- Gated by `testing.Short()` — skipped in short mode
- Tests actual plugin downloads, component transfers, signing against live registries
- Internal helpers: `credentials.go` (htpasswd, Docker auth), `oci.go` (registry setup)

```bash
cd cli/integration
task test
```

**What's tested**: Output formats (table, YAML, JSON, NDJSON, tree), component add/get/sign/verify/transfer flows, credential handling, plugin downloads.

---

## kubernetes/controller/

### Structure

```
kubernetes/controller/
├── cmd/main.go                     # Entry point, initializes 4 controllers
├── api/v1alpha1/                   # CRD types
├── internal/
│   ├── controller/
│   │   ├── component/              # Component reconciliation
│   │   ├── resource/               # Resource fetching
│   │   ├── deployer/               # Deployer with ApplySet, dynamic watches
│   │   ├── repository/             # Repository validation
│   │   └── applyset/               # ApplySet management
│   ├── ocm/                        # Base reconciler, config propagation, verification
│   ├── resolution/                 # Cached resolution service, worker pool
│   ├── configuration/              # Config parsing
│   ├── setup/                      # Plugin manager, credential init
│   ├── status/                     # Status/condition helpers
│   ├── test/                       # Test helpers (mocks, builders)
│   ├── cel/                        # CEL expression support
│   ├── context/                    # Context utilities
│   ├── event/                      # Event recording
│   └── metrics/                    # Prometheus metrics
├── config/
│   ├── crd/bases/                  # Generated CRD manifests
│   ├── rbac/                       # RBAC roles (editor/viewer per resource)
│   └── default/                    # Kustomize base
├── chart/                          # Helm chart
├── test/e2e/                       # E2E tests (KIND cluster)
└── examples/                       # Example manifests for E2E
```

### CRDs

Four custom resources in `api/v1alpha1/`:

| CRD | Purpose |
|-----|---------|
| **Component** | References a Repository, specifies component name + semver constraints, verification, downgrade policy |
| **Repository** | Stores OCM repository specification (JSON), reconciliation interval |
| **Resource** | References a Component, identifies an OCM resource via ResourceID |
| **Deployer** | References a Resource, tracks deployed objects, ApplySet pruning |

**Reconciliation flow**: Repository → Component → Resource → Deployer (dependency chain).

Configuration propagation uses policy (Propagate/DoNotPropagate) from parent to child objects.

### Controllers

All controllers embed `*ocm.BaseReconciler` (provides Client, Scheme, EventRecorder) and use controller-runtime builder patterns.

- **Component**: Field indexing on `spec.repositoryRef.name`, semver resolution, signature verification
- **Resource**: Parallel execution with `errgroup`, resource verification/download/caching
- **Deployer**: Dynamic resource watching via channels, ApplySet pruning finalizer, RESTMapper for dynamic resources, Kro ResourceGraphDefinition support
- **Repository**: Validates OCM repository specifications, field indexing on `metadata.name`

### Testing

**Framework**: Ginkgo v2 + Gomega (BDD-style). This is the only area using Ginkgo — bindings and CLI use testify.

**Environment**: envtest (controller-runtime test framework).

**Critical env var**:
```bash
export ENVTEST_K8S_VERSION=1.34.1
```

Without this, tests fail with "no such file or directory" because the binary path resolves incorrectly. Binaries live at `kubernetes/controller/bin/k8s/1.34.1-darwin-arm64/`.

**Suite setup** (`suite_test.go` in each controller package):
- `BeforeSuite`: Bootstrap envtest, register CRDs, start manager with metrics disabled (`BindAddress: "0"`)
- Component/Resource suites: Full OCM stack (PluginManager, OCI provider, signing handler, credentials)
- Deployer suite: Includes Kro ResourceGraphDefinition CRD fetching
- Repository suite: Simpler, focuses on validation

**Running tests**:
```bash
cd kubernetes/controller
ENVTEST_K8S_VERSION=1.34.1 go test $(go list ./... | grep -v /e2e) -v
```

Or via task:
```bash
cd kubernetes/controller
task test
```

**Filtering Ginkgo tests**: Use `--ginkgo.focus`, not `-run`:
```bash
ENVTEST_K8S_VERSION=1.34.1 go test ./internal/controller/component/ -v --ginkgo.focus="should reconcile"
```

**Test helpers** (`internal/test/`):
- `component.go`: `MockComponent`, `SignComponent` (RSA key generation, X.509 cert creation)
- `k8s.go`, `resource.go`, `ocmrepository.go`: Mock object builders
- Event channel handling with GinkgoLogr logging

**E2E tests** (`test/e2e/`):
- Run against a KIND cluster with Helm-deployed controller
- Use Ginkgo, 30-minute timeout
- Tests: ApplySet deployment, credential handling, example manifests
- Utils for kubectl command execution

```bash
cd kubernetes/controller
task test/e2e
```

### Helm Chart

Located at `kubernetes/controller/chart/`. CRDs and RBAC are auto-synced via kubebuilder edit.

```bash
cd kubernetes/controller
task helm:lint
task helm:template
task helm:package
```

---

## Common Workflows

### Adding a New Repository Type
1. Create module under `bindings/go/`
2. Implement `repository.ComponentVersionRepository` interface
3. Add type registration in scheme
4. Add markers: `// +ocm:typegen=true` and `// +k8s:deepcopy-gen=true`
5. Run `task generate`
6. Write unit tests with `testify/require`
7. Add integration tests in `integration/` subdirectory if needed

### Creating a Plugin
- Plugins live in `bindings/go/plugin/`. Refer to existing plugin implementations for current patterns.
- A plugin must support two commands: `capabilities` (return JSON) and `server --config=<json>` (start server).

### Adding a CLI Command
1. Navigate to `cli/cmd/`
2. Create command file following Cobra pattern with `New()` returning `*cobra.Command`
3. Register in parent command via `cmd.AddCommand()`
4. Add completion functions if needed
5. Update CLI tests
6. Run `task build` to verify

### Modifying Component Descriptor Schema
1. Edit types in `bindings/go/descriptor/v2/`
2. Add `// +ocm:jsonschema-gen=true` marker
3. Update normalization logic if needed
4. Run `task generate`
5. Update conformance tests in `testdata/`
6. Verify with `task test`

### Working with Credentials
Resolution order: direct credentials → indirect via credential graph → fallback to defaults.

Adding a credential type:
1. Implement in `bindings/go/credentials/`
2. Register type in scheme
3. Add resolution logic
4. Test with both direct and indirect paths

### Updating Dependencies
```bash
go get <module>@<version>
task tidy
```
Renovate handles automatic updates. Auto-merge for minor/patch, manual review for major.

## Common Pitfalls

1. **Missing ENVTEST_K8S_VERSION** — Controller tests will fail silently with path errors
2. **Cross-module PRs** — CI rejects PRs that mix changes across multiple Go modules
3. **Forgetting `task generate`** — After adding/changing markers, generated code must be committed
4. **Using `-run` with Ginkgo** — Use `--ginkgo.focus` instead
5. **Interactive git** — Don't use `-i` flags in scripts
6. **Context** — Always pass `context.Context` through APIs
7. **APIs are WIP** — Expect changes, especially in bindings

## Dependency Management

- Renovate handles updates automatically
- Auto-merge for minor/patch, manual review for major
- OCM monorepo deps update only at 22:00-06:00 UTC
- After manual updates: `go get <module>@<version> && task tidy`

## Release Strategy

- Tag format: `cli/vX.Y.Z`, `kubernetes/controller/vX.Y.Z`
- Lockstep MAJOR/MINOR between components, independent PATCH
- Development on `main`, releases from `releases/X.Y` branches
- Support window: y-2 versions (~3 months)

## Architecture Decision Records

Located in `docs/adr/`. 16 ADRs covering plugins, credentials, transfer, signing, controller migration, release strategy, plugin registry, and OCI format compatibility. Template at `docs/adr/0000_template.md`.

## Debugging

```bash
ocm --loglevel debug <command>                    # CLI debug logging
./my-plugin server --config='...' 2>&1 | tee plugin.log  # Plugin logs
ocm get componentversion <component> -o yaml      # Inspect descriptors
task jsonschema:validate                          # Validate schemas
```

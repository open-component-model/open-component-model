name: CLI

on:
  # Trigger workflow on pushes to main or release branches, and on PRs targeting main as well as release tags
  # if we are on a PR, limit runtime and only build the cli if it has been modified.
  # if we are on a push, build the CLI regardless of what has changed to always be up to date
  # also allow manual triggering for rebuilds or failing jobs or rebuilding the artifact
  push:
    branches:
      - main
      - 'releases/v**'
    tags:
      - 'cli/v**'
  pull_request:
    branches:
      - main
    paths:
      - 'cli/v**'
      - '.github/workflows/cli.yml'
  workflow_call:
    inputs:
      artifact_name:
        description: "The artifact name to build."
        type: string
        required: false
      ref:
        description: "The ref to build on (branch or tag). Defaults to the current ref."
        type: string
        required: false
    outputs:
      artifact_name:
        description: "The artifact name that was built."
        value: ${{ jobs.build.outputs.artifact_name }}
      artifact_id:
        description: "The artifact id that was built."
        value: ${{ jobs.build.outputs.artifact_id }}

env:
  LOCATION: "cli"                       # Folder containing the CLI source
  REGISTRY: ghcr.io                     # Target container registry
  # github.base_ref → branch name from the PR target (works only for pull_request events)
  # github.ref_name → branch or tag name for normal push/tag events
  # inputs.ref → overrides both for workflow_call
  REF: ${{ inputs.ref || github.base_ref || github.ref_name }}
  ARTIFACT_NAME: ${{ inputs.artifact_name || 'cli-artifacts' }}

jobs:
  build:
    name: Build CLI
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ env.ARTIFACT_NAME }}
      artifact_id: ${{ steps.upload-artifacts.outputs.artifact_id }}
      should_push_oci_image: ${{ steps.branch-check.outputs.should_push_oci_image }}  # Used by publish job
    permissions:
      contents: read
      id-token: write         # Needed for provenance attestations
      attestations: write     # Allows storing build attestations
    steps:
      # Checkout only the CLI
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          sparse-checkout: ${{ env.LOCATION }}
          persist-credentials: 'false'  # Disable automatic token persistence
          ref: ${{ env.REF }}

      - name: Setup Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6
        with:
          go-version-file: cli/go.mod
          cache-dependency-path: cli/go.sum  # Cache dependencies by go.sum

      - name: Install Task
        uses: arduino/setup-task@v2
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          version: 3.x

      # Setup Docker Buildx for multi-arch and advanced image building
      - name: Setup docker/buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

      # Compute VERSION from env.REF
      - name: Compute VERSION
        id: version
        uses: actions/github-script@v8
        with:
          script: |
            const ref = process.env.REF;

            // Determine ref type purely by pattern
            const isTag = /^cli\/v\d+\.\d+(\.\d+)?(-.*)?$/.test(ref);

            let version;
            if (isTag) {
              // Strip 'cli/' prefix from tag name, e.g. cli/v1.2.3 -> 1.2.3
              version = ref.replace(/^cli\/v/, "");
            } else {
              // Convert branch or other ref to semver-safe pseudo version, e.g. releases/v0.1 -> 0.0.0-releases-v0.1
              version = `0.0.0-${ref.replace(/[\/+]/g, "-")}`;
            }

            core.exportVariable("VERSION", version);
            core.info(`Computed VERSION=${version} from REF=${ref}`);

      # Generate and verify the Component Transport Format (CTF) resulting in all artifacts
      # use a version that includes the branch name to ensure uniqueness
      # make sure that the version doesnt contain invalid semver characters
      - name: Generate & Verify CTF
        run: |
          task cli:generate/ctf VERSION="${VERSION}"
          task cli:verify/ctf

      # Attest built binaries with provenance metadata, but only if we're not on a PR
      - name: Attest binaries
        if: ${{ github.event_name != 'pull_request' }}
        uses: actions/attest-build-provenance@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          subject-path: "${{ env.LOCATION }}/tmp/bin/ocm-*"

      # Determine if this branch is eligible for publishing, but only if we're not on a PR
      - name: Determine if this is a push-eligible branch
        if: ${{ github.event_name != 'pull_request' }}
        id: branch-check
        uses: actions/github-script@v8
        with:
          script: |
            core.setOutput(
              "should_push_oci_image",
              process.env.GITHUB_REF_NAME === context.payload.repository.default_branch ||
              /^releases\/v0\./.test(process.env.GITHUB_REF_NAME) ||
              /^cli\/v\d+\.\d+(\.\d+)?(-.*)?$/.test(process.env.GITHUB_REF_NAME)
            )

      # Upload CLI binaries and OCI layout only if branch is eligible for push
      - name: Upload Artifacts
        if: ${{ steps.branch-check.outputs.should_push_oci_image }}
        uses: actions/upload-artifact@v4
        id: upload-artifacts
        with:
          if-no-files-found: 'error'
          name: ${{ env.ARTIFACT_NAME }}
          # Compiled CLI binaries
          # OCI layout files
          path: |
            ${{ env.LOCATION }}/tmp/bin/ocm-*    
            ${{ env.LOCATION }}/tmp/oci/*      

  publish:
    name: Push & Attest
    needs: build
    if: ${{ needs.build.outputs.should_push_oci_image == 'true' }}  # Skip unless we should push
    runs-on: ubuntu-latest
    permissions:
      actions: read           # Needed for artifact download
      packages: write         # Needed for pushing OCI images and provenance layers
      id-token: write         # Needed for provenance attestation identity
      attestations: write     # Allows storing provenance attestation
    steps:
      # Retrieve artifacts produced by the build job
      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: ${{ env.ARTIFACT_NAME }}

      - name: Set LAYOUT
        env:
          LAYOUT: ${{ github.workspace }}/oci/cli.tar
        run: |
          test -e "$LAYOUT" || exit 1
          echo "LAYOUT=$LAYOUT" >> "$GITHUB_ENV"

      # Setup ORAS CLI for pushing OCI artifacts from OCI layouts.
      - name: Setup ORAS
        uses: oras-project/setup-oras@v1

      # use discovered tag from layout
      - name: Set TAG
        run: echo "TAG=$(oras repo tags --oci-layout ${LAYOUT} | head -n 1)" >> "$GITHUB_ENV"

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Define target repository path in environment
      - name: Set TARGET_REPO
        run: echo "TARGET_REPO=${REGISTRY}/${GITHUB_REPOSITORY_OWNER}/cli" >> "$GITHUB_ENV"

      # Push the OCI layout as an image to GHCR
      - name: Push OCI image
        id: push-oci
        run: oras cp --from-oci-layout "${LAYOUT}:${TAG}" "${TARGET_REPO}:${TAG}"

      # This is only convenience so when we push to main there is a CLI image that always points to main as well
      # technically we already have a tagged version called 0.0.0-main but this is more standard
      - name: Tag Image as branch when default ( :${{ env.REF }} )
        if: ${{ env.REF == github.event.repository.default_branch }}
        env:
          FROM: ${{ env.TAG }}
          TO: ${{ env.REF }}
        run: oras tag "${TARGET_REPO}:${FROM}" "${TARGET_REPO}:${TO}"

      # Attest pushed OCI image with provenance metadata
      - name: Resolve Pushed Digest for Attestation
        id: digest
        run: echo "digest=$(oras resolve ${TARGET_REPO}:${TAG})" >> "$GITHUB_OUTPUT"
      - name: Attest OCI image
        uses: actions/attest-build-provenance@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          subject-name: ${{ env.TARGET_REPO }}
          push-to-registry: true
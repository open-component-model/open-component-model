version: '3'

env:
  CONTROLLER_IMG: '{{ env "CONTROLLER_IMG" | default "ghcr.io/open-component-model/kubernetes/controller:latest" }}'

vars:
  GOBIN:
    sh: 'go env GOBIN || echo $(go env GOPATH)/bin'
  PROJECT_ROOT:
    sh: 'git rev-parse --show-toplevel'

  # Tool versions: load from project root, then override with local .env if set
  KUSTOMIZE_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "$KUSTOMIZE_VERSION"'
  CONTROLLER_TOOLS_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "$CONTROLLER_TOOLS_VERSION"'
  ENVTEST_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "$ENVTEST_VERSION"'
  ENVTEST_K8S_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "$ENVTEST_K8S_VERSION"'
  KIND_NODE_IMAGE_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "$KIND_NODE_IMAGE_VERSION"'
  HELM_DOCS_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "${HELM_DOCS_VERSION:-v1.14.2}"'
  KUBEBUILDER_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "${KUBEBUILDER_VERSION:-v4.11.1}"'
  YQ_VERSION:
    sh: 'source {{.PROJECT_ROOT}}/.env && [ -f .env ] && source .env; echo "${YQ_VERSION:-v4.49.2}"'
  
  CONTAINER_TOOL: '{{.CONTAINER_TOOL | default "docker"}}'
  LOCALBIN: '{{.TASKFILE_DIR}}/bin'
  KUBECTL: '{{.KUBECTL | default "kubectl"}}'
  KUSTOMIZE: '{{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}}'
  CONTROLLER_GEN: '{{.LOCALBIN}}/controller-gen-{{.CONTROLLER_TOOLS_VERSION}}'
  ENVTEST: '{{.LOCALBIN}}/setup-envtest-{{.ENVTEST_VERSION}}'
  HELM_DOCS: '{{.LOCALBIN}}/helm-docs-{{.HELM_DOCS_VERSION}}'
  KUBEBUILDER: '{{.LOCALBIN}}/kubebuilder-{{.KUBEBUILDER_VERSION}}'
  YQ: '{{.LOCALBIN}}/yq-{{.YQ_VERSION}}'
  IGNORE_NOT_FOUND: '{{.IGNORE_NOT_FOUND | default "false"}}'
  PLATFORMS: '{{.PLATFORMS | default "linux/arm64,linux/amd64"}}'

tasks:
  default:
    cmds: [ task: build ]

  # Development
  manifests:
    deps: [controller-gen]
    cmd: '"{{.CONTROLLER_GEN}}" rbac:roleName=manager-role crd webhook paths="{{ .TASKFILE_DIR }}/..." output:crd:artifacts:config=config/crd/bases'

  generate:
    deps: [controller-gen]
    cmd: '"{{.CONTROLLER_GEN}}" object paths="{{ .TASKFILE_DIR }}/..."'

  fmt:
    cmd: 'go fmt "{{ .TASKFILE_DIR }}/..."'

  vet:
    cmd: 'go vet "{{ .TASKFILE_DIR }}/..."'

  test:
    deps: [manifests, generate, envtest]
    env:
      ENVTEST_K8S_VERSION: '{{.ENVTEST_K8S_VERSION}}'
    cmds:
      - |
        KUBEBUILDER_ASSETS=$({{ .ENVTEST }} use {{ .ENVTEST_K8S_VERSION }} --bin-dir {{.LOCALBIN}} -p path)
        echo "Using KUBEBUILDER_ASSETS: $KUBEBUILDER_ASSETS"
        go test $(go list ./... | grep -v /e2e) -coverprofile cover.out


  test/e2e/setup/local:
    deps:
      # We depend on a locally built image, so we need to load that into the local machine.
      - task: docker-build
        vars:
          LOAD: "true"
    cmds:
      - 'KIND_NODE_IMAGE_VERSION={{.KIND_NODE_IMAGE_VERSION}} bash test/e2e/hacks/setup.sh'
      - 'kind load docker-image {{.CONTROLLER_IMG}}'

  test/e2e:
    dotenv: ['{{.TASKFILE_DIR}}/test/e2e/hacks/.env']
    cmds:
      - task: helm/install
      - PROJECT_DIR='{{.TASKFILE_DIR}}' go test '{{.TASKFILE_DIR}}/test/e2e/' -v -timeout 30m -ginkgo.v

  # Build
  build:
    deps: [manifests, generate, fmt, vet]
    cmd: 'go build -o bin/manager {{.TASKFILE_DIR}}/cmd/main.go'

  run:
    deps: [manifests, generate, fmt, vet]
    cmd: 'go run {{.TASKFILE_DIR}}/cmd/main.go'


  # Always build only for the host architecture.
  # We force "linux" OS because all Docker base images are Linux,
  # and derive the arch dynamically from the host Go toolchain.
  docker-build:
    cmd:
      task: docker-build/multi-arch
      vars:
        PLATFORMS:
          sh: 'echo "linux/$(go env GOARCH)"'


  # Multi-arch capable build task.
  # In this setup it is used only with a single platform (the local arch),
  # but it still supports --push / --load flags if desired.
  docker-build/multi-arch:
    requires:
      vars: [ PLATFORMS, CONTROLLER_IMG ]
    cmd: |
      args=(
        --platform={{.PLATFORMS}}
        -f '{{.TASKFILE_DIR}}/Dockerfile' '{{.TASKFILE_DIR}}'
      )

      # Add tags - CONTROLLER_IMG can be space-separated for multiple tags
      for tag in {{.CONTROLLER_IMG}}; do
        args+=(-t "$tag")
      done

      # If LOAD is set, load single-arch image into local daemon
      if [ "{{.LOAD | default ""}}" = "true" ]; then
        args+=(--load)
      fi

      # If PUSH is set, push image (or manifest) to registry
      if [ "{{.PUSH | default ""}}" = "true" ]; then
        args+=(--push)
      fi

      # Run docker (or podman) buildx with the constructed args
      {{.CONTAINER_TOOL}} buildx build "${args[@]}"

  build-installer:
    deps: [manifests, generate, kustomize]
    cmds:
      - mkdir -p dist
      - '{{.KUSTOMIZE}} build config/default > dist/install.yaml'


  # Helm chart tasks
  helm/sync-manifests:
    desc: "Regenerate CRDs and RBAC for Helm chart"
    deps: [manifests, kubebuilder]
    cmds:
      - '"{{.KUBEBUILDER}}" edit --plugins=helm/v2-alpha --output-dir .'
      - rm .github/workflows/test-chart.yml # Plugin generates github workflow which we do not need

  helm/schema:
    desc: "Generate JSON schema from chart values.yaml"
    silent: true
    deps: [helm-schema-plugin]
    dir: chart
    cmd: 'helm schema -f values.yaml -o values.schema.json'
    sources:
      - chart/values.yaml
    generates:
      - chart/values.schema.json

  helm/lint:
    desc: "Lint the Helm chart"
    cmd: 'helm lint chart/'

  helm/validate:
    desc: "Validate the Helm chart (lint, template, and verify CRDs/RBAC are in sync)"
    silent: true
    cmds:
      - task: helm/lint
      - task: helm/template
      - task: helm/schema
      - task: helm/docs
      - task: helm/sync-manifests
      - |
        if ! git diff --quiet chart/templates/crd chart/templates/rbac chart/values.schema.json chart/README.md; then
          echo "ERROR: CRDs, RBAC, schema or docs are out of sync. Run 'task helm/sync-manifests' and commit the changes."
          git diff chart/templates/crd chart/templates/rbac chart/values.schema.json chart/README.md
          exit 1
        fi

  helm/package:
    desc: "Package the Helm chart with the specified version"
    deps: [yq]
    cmds:
      - mkdir -p dist
      - '{{ if .VERSION }}{{.YQ}} -i ".manager.image.tag = \"{{.VERSION}}\"" chart/values.yaml{{end}}'
      - helm package chart/ --destination dist/ {{if .VERSION}}--version {{.VERSION}}{{end}} {{if .APP_VERSION}}--app-version {{.APP_VERSION}}{{end}}

  helm/template:
    desc: "Render Helm chart templates with test values"
    silent: true
    cmds:
      - mkdir -p dist
      - helm template ocm-k8s-toolkit chart/ --namespace ocm-k8s-toolkit-system -f chart/test-values.yaml > dist/generated.yaml

  helm/install:
    desc: "Install the Helm chart"
    cmds:
      - |
        helm upgrade --install ocm-k8s-toolkit chart/ \
          -f chart/test-values.yaml \
          --namespace ocm-k8s-toolkit-system \
          --create-namespace \
          --wait \
          --timeout 120s

  helm/uninstall:
    desc: "Uninstall the Helm chart"
    cmd: 'helm uninstall ocm-k8s-toolkit --namespace ocm-k8s-toolkit-system --ignore-not-found'

  helm/docs:
    desc: "Generate Helm chart documentation"
    deps: [helm-docs]
    dir: chart
    cmd: '"{{.HELM_DOCS}}"'
    sources:
      - chart/values.yaml
      - chart/README.md
    generates:
      - chart/README.md

  # Tool installers (all via helper)
  kustomize:
    deps:
      - task: go-install-tool
        vars: { TOOL_PATH: '{{.KUSTOMIZE}}', PACKAGE: sigs.k8s.io/kustomize/kustomize/v5, VERSION: '{{.KUSTOMIZE_VERSION}}' }
    generates: [ '{{.KUSTOMIZE}}' ]

  controller-gen:
    deps:
      - task: go-install-tool
        vars: { TOOL_PATH: '{{.CONTROLLER_GEN}}', PACKAGE: sigs.k8s.io/controller-tools/cmd/controller-gen, VERSION: '{{.CONTROLLER_TOOLS_VERSION}}' }
    generates: [ '{{.CONTROLLER_GEN}}' ]

  envtest:
    deps:
      - task: go-install-tool
        vars: { TOOL_PATH: '{{.ENVTEST}}', PACKAGE: sigs.k8s.io/controller-runtime/tools/setup-envtest, VERSION: '{{.ENVTEST_VERSION}}' }
    generates: [ '{{.ENVTEST}}' ]

  kubebuilder:
    deps:
      - task: go-install-tool
        vars: { TOOL_PATH: '{{.KUBEBUILDER}}', PACKAGE: sigs.k8s.io/kubebuilder/v4, VERSION: '{{.KUBEBUILDER_VERSION}}' }
    generates: [ '{{.KUBEBUILDER}}' ]

  yq:
    deps:
      - task: go-install-tool
        vars: { TOOL_PATH: '{{.YQ}}', PACKAGE: github.com/mikefarah/yq/v4, VERSION: '{{.YQ_VERSION}}' }
    generates: [ '{{.YQ}}' ]

  go-install-tool:
    internal: true
    silent: true
    desc: "Install a go tool to a specific path"
    cmd: |
      set -e
      tmp=$(mktemp -d)
      trap 'rm -rf "$tmp"' EXIT
      
      # install into temp dir
      GOBIN=$tmp go install {{.PACKAGE}}@{{.VERSION}}
      
      # figure out binary name (strip version suffix if present)
      name=$(basename {{.TOOL_PATH}} | sed 's/-{{.VERSION}}$//')
      
      # move binary if names differ
      if [ "$name" != "$(basename {{.TOOL_PATH}})" ]; then
        # make sure target dir exists
        mkdir -p "$(dirname {{.TOOL_PATH}})"
        mv "$tmp/$name" {{.TOOL_PATH}}
      fi
    generates:
      - '{{.TOOL_PATH}}'

  helm-docs:
    deps:
      - task: go-install-tool
        vars: { TOOL_PATH: '{{.HELM_DOCS}}', PACKAGE: github.com/norwoodj/helm-docs/cmd/helm-docs, VERSION: '{{.HELM_DOCS_VERSION}}' }
    generates: [ '{{.HELM_DOCS}}' ]

  helm-schema-plugin:
    internal: true
    silent: true
    desc: "Install helm-values-schema-json plugin if not present"
    cmd: |
      if ! helm plugin list | grep -q "schema"; then
        helm plugin install https://github.com/losisin/helm-values-schema-json
      fi
    status:
      - helm plugin list | grep -q "schema"

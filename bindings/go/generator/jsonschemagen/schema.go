package jsonschemagen

import (
	"bytes"
	"encoding/json"
	"go/ast"
	"slices"

	"ocm.software/open-component-model/bindings/go/generator/universe"
)

const (
	JSONSchemaDraft202012URL = "https://json-schema.org/draft/2020-12/schema"
	GeneratedComment         = "generated by the ocm schema generation tool"
)

// JSONSchemaDraft202012 represents a JSON Schema Draft 2020-12 structure.
//
// see JSONSchemaDraft202012URL
type JSONSchemaDraft202012 struct {
	Schema      string `json:"$schema,omitempty"`
	Comment     string `json:"$comment,omitempty"`
	ID          string `json:"$id,omitempty"`
	Title       string `json:"title,omitempty"`
	Type        string `json:"type,omitempty"`
	Deprecated  *bool  `json:"deprecated,omitempty"`
	Ref         string `json:"$ref,omitempty"`
	Description string `json:"description,omitempty"`
	Format      string `json:"format,omitempty"`

	Const any `json:"const,omitempty"`

	// numeric validation
	Minimum          *float64 `json:"minimum,omitempty"`
	Maximum          *float64 `json:"maximum,omitempty"`
	ExclusiveMinimum *float64 `json:"exclusiveMinimum,omitempty"`
	ExclusiveMaximum *float64 `json:"exclusiveMaximum,omitempty"`

	// string validation
	MinLength *int   `json:"minLength,omitempty"`
	MaxLength *int   `json:"maxLength,omitempty"`
	Pattern   string `json:"pattern,omitempty"`

	// array validation
	MinItems    *int  `json:"minItems,omitempty"`
	MaxItems    *int  `json:"maxItems,omitempty"`
	UniqueItems *bool `json:"uniqueItems,omitempty"`

	// object validation
	MinProperties *int                              `json:"minProperties,omitempty"`
	MaxProperties *int                              `json:"maxProperties,omitempty"`
	Properties    map[string]*JSONSchemaDraft202012 `json:"properties,omitempty"`
	Enum          []any                             `json:"enum,omitempty"`

	Required             []string      `json:"required,omitempty"`
	AdditionalProperties *SchemaOrBool `json:"additionalProperties,omitempty"`

	OneOf []*JSONSchemaDraft202012 `json:"oneOf,omitempty"`

	// $defs support
	Defs map[string]*JSONSchemaDraft202012 `json:"$defs,omitempty"`

	Items *JSONSchemaDraft202012 `json:"items,omitempty"`
}

type SchemaOrBool struct {
	Schema *JSONSchemaDraft202012
	Bool   *bool
}

func (sb SchemaOrBool) MarshalJSON() ([]byte, error) {
	if sb.Bool != nil {
		return json.Marshal(*sb.Bool)
	}
	return json.Marshal(sb.Schema)
}

func (sb *SchemaOrBool) UnmarshalJSON(data []byte) error {
	if bytes.EqualFold(data, []byte("true")) || bytes.EqualFold(data, []byte("false")) {
		var b bool
		if err := json.Unmarshal(data, &b); err != nil {
			return err
		}
		sb.Bool = &b
		return nil
	}

	var sch JSONSchemaDraft202012
	if err := json.Unmarshal(data, &sch); err != nil {
		return err
	}
	sb.Schema = &sch
	return nil
}

func (g *Generator) buildRootSchema(ti *universe.TypeInfo) *JSONSchemaDraft202012 {
	if universe.IsRuntimeRaw(ti) {
		return g.builtinRuntimeRaw()
	}
	if universe.IsRuntimeTyped(ti) {
		return g.builtinRuntimeTyped()
	}
	if universe.IsRuntimeType(ti) {
		return g.builtinRuntimeType()
	}

	if ti.Struct != nil {
		desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)
		sch := &JSONSchemaDraft202012{
			Schema:               JSONSchemaDraft202012URL,
			Comment:              GeneratedComment,
			ID:                   g.schemaID(ti),
			Title:                ti.Key.TypeName,
			Description:          desc,
			Type:                 "object",
			Properties:           g.buildStructProperties(ti.Struct, ti),
			Required:             g.buildStructRequired(ti.Struct),
			AdditionalProperties: &SchemaOrBool{Bool: Ptr(false)},
		}

		if deprecated {
			sch.Deprecated = Ptr(true)
		}
		return sch
	}

	return g.buildAliasSchema(ti)
}

func (g *Generator) buildAliasSchema(ti *universe.TypeInfo) *JSONSchemaDraft202012 {
	desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)

	switch t := ti.Expr.(type) {
	case *ast.Ident: // type Foo string
		if prim := newPrimitiveSchema(t, ti.TypeSpec, ti.GenDecl, nil); prim != nil {
			prim.Comment = GeneratedComment
			prim.Schema = JSONSchemaDraft202012URL
			prim.Description = desc
			prim.ID = g.schemaID(ti)
			prim.Title = ti.Key.TypeName
			if deprecated {
				prim.Deprecated = Ptr(true)
			}
			return prim
		}
	case *ast.ArrayType: // type Foo []Bar
		return &JSONSchemaDraft202012{
			Schema:  JSONSchemaDraft202012URL,
			Comment: GeneratedComment,
			ID:      g.schemaID(ti),
			Title:   ti.Key.TypeName,
			Type:    "array",
			Items:   g.schemaForExprWithOptionalField(t.Elt, ti, nil),
		}
	case *ast.MapType: // type Foo map[string]Bar
		return &JSONSchemaDraft202012{
			Schema:  JSONSchemaDraft202012URL,
			Comment: GeneratedComment,
			ID:      g.schemaID(ti),
			Title:   ti.Key.TypeName,
			Type:    "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: g.schemaForExprWithOptionalField(t.Value, ti, nil),
			},
		}
	}

	// fallback
	return anyObjectSchema()
}

func (g *Generator) buildStructProperties(st *ast.StructType, ti *universe.TypeInfo) map[string]*JSONSchemaDraft202012 {
	props := map[string]*JSONSchemaDraft202012{}

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		jsonName, _ := parseJSONTagWithFieldNameFallback(field)
		if jsonName == "-" {
			continue
		}

		sch := g.schemaForExprWithOptionalField(field.Type, ti, field)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = Ptr(true)
		}

		props[jsonName] = sch
	}

	return props
}

func (g *Generator) buildStructRequired(st *ast.StructType) []string {
	var req []string
	for _, f := range st.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		name, opts := parseJSONTagWithFieldNameFallback(f)
		if name == "-" {
			continue
		}
		if slices.Contains(opts, "omitempty") {
			continue
		}
		req = append(req, name)
	}
	return req
}

func (g *Generator) schemaForExprWithOptionalField(
	expr ast.Expr,
	ctx *universe.TypeInfo,
	field *ast.Field,
) *JSONSchemaDraft202012 {
	switch t := expr.(type) {
	case *ast.Ident:
		return g.schemaForIdentWithField(t, ctx, field)
	case *ast.SelectorExpr:
		return g.schemaForSelector(t, ctx, field)
	case *ast.StarExpr:
		return g.schemaForExprWithOptionalField(t.X, ctx, field)
	case *ast.ArrayType:
		return &JSONSchemaDraft202012{
			Type:  "array",
			Items: g.schemaForExprWithOptionalField(t.Elt, ctx, field),
		}
	case *ast.MapType:
		return &JSONSchemaDraft202012{
			Type: "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: g.schemaForExprWithOptionalField(t.Value, ctx, field),
			},
		}
	case *ast.StructType:
		return g.inlineAnonymousStruct(t, ctx)
	default:
		return anyObjectSchema()
	}
}

func (g *Generator) schemaForIdentWithField(id *ast.Ident, ctx *universe.TypeInfo, field *ast.Field) *JSONSchemaDraft202012 {
	// try to resolve named type â†’ $ref
	if ti, ok := g.U.ResolveIdent(ctx.FilePath, ctx.Key.PkgPath, id); ok {
		sch := &JSONSchemaDraft202012{
			Ref: "#/$defs/" + universe.Definition(ti.Key),
		}
		return sch
	}

	// primitive with field markers
	if prim := newPrimitiveSchema(id, ctx.TypeSpec, ctx.GenDecl, field); prim != nil {
		return prim
	}

	return anyObjectSchema()
}

func (g *Generator) schemaForSelector(sel *ast.SelectorExpr, ctx *universe.TypeInfo, field *ast.Field) *JSONSchemaDraft202012 {
	var base *JSONSchemaDraft202012
	if ti, ok := g.U.ResolveSelector(ctx.FilePath, sel); ok {
		base = &JSONSchemaDraft202012{}
		if schema, ok := SchemaFromUniverseType(ti); ok {
			// if the schema is based on the type, embed
			// it directly as a nested reference instead of attempting
			// to link it to the $defs section.
			ApplyFileMarkers(base, schema, ti.FilePath)
			return base
		}
		base.Ref = "#/$defs/" + universe.Definition(ti.Key)
	} else {
		base = anyObjectSchema()
	}
	// type level markers
	typeMarkers := ExtractMarkerMap(ctx.TypeSpec, ctx.GenDecl, BaseMarker)
	ApplyEnumMarkers(base, typeMarkers)
	ApplyNumericMarkers(base, typeMarkers)

	// field level markers
	fieldMarkers := ExtractMarkerMapFromField(field, BaseMarker)
	ApplyEnumMarkers(base, fieldMarkers)
	ApplyNumericMarkers(base, fieldMarkers)
	return base
}

func (g *Generator) collectReachableQueue(root *universe.TypeInfo) []*universe.TypeInfo {
	seen := map[universe.TypeKey]bool{}
	var out []*universe.TypeInfo

	var walk func(*universe.TypeInfo)
	walk = func(ti *universe.TypeInfo) {
		if seen[ti.Key] {
			return
		}
		seen[ti.Key] = true

		// root is NOT included
		if ti != root {
			out = append(out, ti)
		}

		if universe.IsRuntimeTyped(ti) {
			// if we are in runtime typed then we also see runtime raw because its part of our generic typed
			// definition.
			// but because Typed is an interface, we will never reach them by normal walking.
			// Instead, we enforce this here.
			if rt := g.U.LookupType(universe.RuntimePackage, "Raw"); rt != nil {
				walk(rt)
			}
		}

		// follow fields only if struct
		if ti.Struct != nil {
			for _, f := range ti.Struct.Fields.List {
				g.collectFromExpr(f.Type, ti, walk)
			}
		} else {
			// alias types also need traversal
			g.collectFromExpr(ti.Expr, ti, walk)
		}
	}

	walk(root)
	return out
}

func (g *Generator) collectFromExpr(expr ast.Expr, ctx *universe.TypeInfo, walk func(*universe.TypeInfo)) {
	switch t := expr.(type) {
	case *ast.Ident:
		if ti, ok := g.U.ResolveIdent(ctx.FilePath, ctx.Key.PkgPath, t); ok {
			walk(ti)
		}
	case *ast.SelectorExpr:
		if ti, ok := g.U.ResolveSelector(ctx.FilePath, t); ok {
			if _, ok := SchemaFromUniverseType(ti); ok {
				// schema from file discovered, that means
				// all types below this type are not relevant
				// for schema generation and should be skipped from
				// the walking queue.
				return
			}
			walk(ti)
		}
	case *ast.StarExpr:
		g.collectFromExpr(t.X, ctx, walk)
	case *ast.ArrayType:
		g.collectFromExpr(t.Elt, ctx, walk)
	case *ast.MapType:
		g.collectFromExpr(t.Value, ctx, walk)
	case *ast.StructType:
		for _, f := range t.Fields.List {
			g.collectFromExpr(f.Type, ctx, walk)
		}
	}
}

func (g *Generator) inlineAnonymousStruct(st *ast.StructType, ctx *universe.TypeInfo) *JSONSchemaDraft202012 {
	props := map[string]*JSONSchemaDraft202012{}
	var req []string

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		name, opts := parseJSONTagWithFieldNameFallback(field)
		if name == "-" {
			continue
		}

		sch := g.schemaForExprWithOptionalField(field.Type, ctx, field)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = Ptr(true)
		}

		props[name] = sch

		if slices.Contains(opts, "omitempty") {
			continue
		}
		req = append(req, name)
	}

	return &JSONSchemaDraft202012{
		Type:                 "object",
		Properties:           props,
		Required:             req,
		AdditionalProperties: &SchemaOrBool{Bool: Ptr(false)},
	}
}

func (g *Generator) schemaID(ti *universe.TypeInfo) string {
	return ti.Key.PkgPath + "/schemas/" + ti.Key.TypeName + ".schema.json"
}

func anyObjectSchema() *JSONSchemaDraft202012 {
	return &JSONSchemaDraft202012{
		Type:                 "object",
		AdditionalProperties: &SchemaOrBool{Bool: Ptr(true)},
	}
}

func Ptr[T any](v T) *T { return &v }

package jsonschemagen

import (
	"bytes"
	"encoding/json"
	"go/ast"
	"slices"

	"ocm.software/open-component-model/bindings/go/generator/universe"
)

const (
	JSONSchemaDraft202012URL = "https://json-schema.org/draft/2020-12/schema"
	GeneratedComment         = "generated by the ocm schema generation tool"
)

type JSONSchemaDraft202012 struct {
	Schema      string `json:"$schema,omitempty"`
	Comment     string `json:"$comment,omitempty"`
	ID          string `json:"$id,omitempty"`
	Title       string `json:"title,omitempty"`
	Type        string `json:"type,omitempty"`
	Deprecated  *bool  `json:"deprecated,omitempty"`
	Ref         string `json:"$ref,omitempty"`
	Description string `json:"description,omitempty"`
	Format      string `json:"format,omitempty"`

	Const any `json:"const,omitempty"`

	Minimum          *float64 `json:"minimum,omitempty"`
	Maximum          *float64 `json:"maximum,omitempty"`
	ExclusiveMinimum *float64 `json:"exclusiveMinimum,omitempty"`
	ExclusiveMaximum *float64 `json:"exclusiveMaximum,omitempty"`

	MinLength *int   `json:"minLength,omitempty"`
	MaxLength *int   `json:"maxLength,omitempty"`
	Pattern   string `json:"pattern,omitempty"`

	MinItems    *int  `json:"minItems,omitempty"`
	MaxItems    *int  `json:"maxItems,omitempty"`
	UniqueItems *bool `json:"uniqueItems,omitempty"`

	MinProperties *int                              `json:"minProperties,omitempty"`
	MaxProperties *int                              `json:"maxProperties,omitempty"`
	Properties    map[string]*JSONSchemaDraft202012 `json:"properties,omitempty"`
	Enum          []any                             `json:"enum,omitempty"`

	Required             []string      `json:"required,omitempty"`
	AdditionalProperties *SchemaOrBool `json:"additionalProperties,omitempty"`

	OneOf []*JSONSchemaDraft202012          `json:"oneOf,omitempty"`
	Defs  map[string]*JSONSchemaDraft202012 `json:"$defs,omitempty"`

	Items *JSONSchemaDraft202012 `json:"items,omitempty"`
}

type SchemaOrBool struct {
	Schema *JSONSchemaDraft202012
	Bool   *bool
}

func (sb SchemaOrBool) MarshalJSON() ([]byte, error) {
	if sb.Bool != nil {
		return json.Marshal(*sb.Bool)
	}
	return json.Marshal(sb.Schema)
}

func (sb *SchemaOrBool) UnmarshalJSON(data []byte) error {
	if bytes.EqualFold(data, []byte("true")) || bytes.EqualFold(data, []byte("false")) {
		var b bool
		if err := json.Unmarshal(data, &b); err != nil {
			return err
		}
		sb.Bool = &b
		return nil
	}

	var sch JSONSchemaDraft202012
	if err := json.Unmarshal(data, &sch); err != nil {
		return err
	}
	sb.Schema = &sch
	return nil
}

func (g *generation) buildRootSchema(ti *universe.TypeInfo) *JSONSchemaDraft202012 {
	switch {
	case universe.IsRuntimeRaw(ti):
		return g.builtinRuntimeRaw()
	case universe.IsRuntimeTyped(ti):
		return g.builtinRuntimeTyped()
	case universe.IsRuntimeType(ti):
		return g.builtinRuntimeType()
	}

	if ti.Struct != nil {
		desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)
		out := &JSONSchemaDraft202012{
			Schema:               JSONSchemaDraft202012URL,
			Comment:              GeneratedComment,
			ID:                   g.schemaID(ti),
			Title:                ti.Key.TypeName,
			Description:          desc,
			Type:                 "object",
			Properties:           g.buildStructProperties(ti.Struct, ti),
			Required:             g.buildStructRequired(ti.Struct, ti),
			AdditionalProperties: &SchemaOrBool{Bool: Ptr(false)},
		}
		if deprecated {
			out.Deprecated = Ptr(true)
		}
		return out
	}

	return g.buildAliasSchema(ti)
}

func (g *generation) buildAliasSchema(ti *universe.TypeInfo) *JSONSchemaDraft202012 {
	desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)

	var sch *JSONSchemaDraft202012

	switch t := ti.Expr.(type) {
	case *ast.Ident:
		if prim := newPrimitiveSchema(t, ti.TypeSpec, ti.GenDecl, nil); prim != nil {
			sch = prim
		}
	case *ast.ArrayType:
		sch = &JSONSchemaDraft202012{
			Type:  "array",
			Items: g.schemaForExpr(t.Elt, ti, nil),
		}
	case *ast.MapType:
		sch = &JSONSchemaDraft202012{
			Type: "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: g.schemaForExpr(t.Value, ti, nil),
			},
		}
	}

	if sch == nil {
		sch = anyObjectSchema()
	}

	sch.Schema = JSONSchemaDraft202012URL
	sch.Comment = GeneratedComment
	sch.ID = g.schemaID(ti)
	sch.Title = ti.Key.TypeName
	sch.Description = desc
	if deprecated {
		sch.Deprecated = Ptr(true)
	}

	ApplyConstEnum(sch, ti.Consts)
	return sch
}

func (g *generation) schemaForExpr(expr ast.Expr, ctx *universe.TypeInfo, field *ast.Field) *JSONSchemaDraft202012 {
	if sch, ok := g.schemaRefForExpr(expr, ctx); ok {
		applyMarkers(sch, ctx.TypeSpec, ctx.GenDecl, field)
		return sch
	}

	switch t := expr.(type) {
	case *ast.StarExpr:
		return g.schemaForExpr(t.X, ctx, field)
	case *ast.ArrayType:
		return &JSONSchemaDraft202012{
			Type:  "array",
			Items: g.schemaForExpr(t.Elt, ctx, field),
		}
	case *ast.MapType:
		return &JSONSchemaDraft202012{
			Type: "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: g.schemaForExpr(t.Value, ctx, field),
			},
		}
	case *ast.StructType:
		return g.inlineAnonymousStruct(t, ctx)
	case *ast.Ident:
		if prim := newPrimitiveSchema(t, ctx.TypeSpec, ctx.GenDecl, field); prim != nil {
			return prim
		}
	}
	return anyObjectSchema()
}

func (g *generation) schemaRefForExpr(expr ast.Expr, ti *universe.TypeInfo) (*JSONSchemaDraft202012, bool) {
	ti, ok := g.U.ResolveExpr(ti.Pkg.TypesInfo, ti.Key.PkgPath, expr)
	if !ok {
		return nil, false
	}

	def := universe.Definition(ti.Key)

	if schema, ok := SchemaFromUniverseType(ti); ok {
		out := &JSONSchemaDraft202012{}
		ApplyFileMarkers(out, schema, ti.FilePath)

		if g.external == nil {
			g.external = map[string]*JSONSchemaDraft202012{}
		}
		// store once
		if _, exists := g.external[def]; !exists {
			g.external[def] = out
		}
	}

	out := &JSONSchemaDraft202012{
		Ref: "#/$defs/" + def,
	}
	return out, true
}

func applyMarkers(
	sch *JSONSchemaDraft202012,
	typeSpec *ast.TypeSpec,
	genDecl *ast.GenDecl,
	field *ast.Field,
) {
	typeMarkers := ExtractMarkerMap(typeSpec, genDecl, BaseMarker)
	ApplyEnumMarkers(sch, typeMarkers)
	ApplyNumericMarkers(sch, typeMarkers)

	if field != nil {
		fieldMarkers := ExtractMarkerMapFromField(field, BaseMarker)
		ApplyEnumMarkers(sch, fieldMarkers)
		ApplyNumericMarkers(sch, fieldMarkers)
	}
}

func (g *generation) buildStructProperties(st *ast.StructType, ti *universe.TypeInfo) map[string]*JSONSchemaDraft202012 {
	props := make(map[string]*JSONSchemaDraft202012)

	for _, field := range st.Fields.List {
		name, opts := parseJSONTagWithFieldNameFallback(field)
		if slices.Contains(opts, "inline") {
			expr := unwrapStar(field.Type)

			ti, ok := g.U.ResolveExpr(ti.Pkg.TypesInfo, ti.Key.PkgPath, expr)
			if !ok || ti.Struct == nil {
				continue
			}

			inlineSchema := g.buildStructProperties(ti.Struct, ti)
			for key, prop := range inlineSchema {
				props[key] = prop
			}
			continue
		}
		// existing logic
		if name == "-" || name == "" {
			continue
		}

		sch := g.schemaForExpr(field.Type, ti, field)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = Ptr(true)
		}

		props[name] = sch
	}
	return props
}

func (g *generation) buildStructRequired(st *ast.StructType, ti *universe.TypeInfo) []string {
	var req []string
	for _, field := range st.Fields.List {
		name, opts := parseJSONTagWithFieldNameFallback(field)
		if slices.Contains(opts, "inline") {
			expr := unwrapStar(field.Type)

			ti, ok := g.U.ResolveExpr(ti.Pkg.TypesInfo, ti.Key.PkgPath, expr)
			if !ok || ti.Struct == nil {
				continue
			}

			req = append(req, g.buildStructRequired(ti.Struct, ti)...)
			continue
		}
		if name == "-" || slices.Contains(opts, "omitempty") {
			continue
		}
		req = append(req, name)
	}
	return req
}

func unwrapStar(expr ast.Expr) ast.Expr {
	for {
		if star, ok := expr.(*ast.StarExpr); ok {
			expr = star.X
			continue
		}
		return expr
	}
}

func (g *generation) inlineAnonymousStruct(st *ast.StructType, ctx *universe.TypeInfo) *JSONSchemaDraft202012 {
	props := map[string]*JSONSchemaDraft202012{}
	var req []string

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		name, opts := parseJSONTagWithFieldNameFallback(field)
		if name == "-" {
			continue
		}

		sch := g.schemaForExpr(field.Type, ctx, field)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = Ptr(true)
		}

		props[name] = sch
		if !slices.Contains(opts, "omitempty") {
			req = append(req, name)
		}
	}

	return &JSONSchemaDraft202012{
		Type:                 "object",
		Properties:           props,
		Required:             req,
		AdditionalProperties: &SchemaOrBool{Bool: Ptr(false)},
	}
}

func (g *generation) collectReachableQueue(root *universe.TypeInfo) []*universe.TypeInfo {
	seen := map[universe.TypeKey]bool{}
	var out []*universe.TypeInfo

	var walk func(*universe.TypeInfo)
	walk = func(ti *universe.TypeInfo) {
		if seen[ti.Key] {
			return
		}
		seen[ti.Key] = true
		if ti != root {
			out = append(out, ti)
		}

		if universe.IsRuntimeTyped(ti) {
			if rt := g.U.LookupType(universe.RuntimePackage, "Raw"); rt != nil {
				walk(rt)
			}
		}

		if ti.Struct != nil {
			for _, f := range ti.Struct.Fields.List {
				if ref, ok := g.U.ResolveExpr(ti.Pkg.TypesInfo, ti.Key.PkgPath, f.Type); ok {
					walk(ref)
				}
				g.collectFromExpr(f.Type, ti, walk)
			}
			return
		}

		g.collectFromExpr(ti.Expr, ti, walk)
	}

	walk(root)
	return out
}

func (g *generation) collectFromExpr(
	expr ast.Expr,
	ctx *universe.TypeInfo,
	walk func(*universe.TypeInfo),
) {
	if ti, ok := g.U.ResolveExpr(ctx.Pkg.TypesInfo, ctx.Key.PkgPath, expr); ok {
		if _, skip := SchemaFromUniverseType(ti); !skip {
			walk(ti)
		}
		return
	}

	switch t := expr.(type) {
	case *ast.StarExpr:
		g.collectFromExpr(t.X, ctx, walk)
	case *ast.ArrayType:
		g.collectFromExpr(t.Elt, ctx, walk)
	case *ast.MapType:
		g.collectFromExpr(t.Value, ctx, walk)
	case *ast.StructType:
		for _, f := range t.Fields.List {
			g.collectFromExpr(f.Type, ctx, walk)
		}
	}
}

func (g *generation) schemaID(ti *universe.TypeInfo) string {
	return ti.Key.PkgPath + "/schemas/" + ti.Key.TypeName + ".schema.json"
}

func anyObjectSchema() *JSONSchemaDraft202012 {
	return &JSONSchemaDraft202012{
		Type:                 "object",
		AdditionalProperties: &SchemaOrBool{Bool: Ptr(true)},
	}
}

func Ptr[T any](v T) *T { return &v }

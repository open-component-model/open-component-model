package jsonschemagen

import (
	_ "embed"
	"encoding/json"
	"go/ast"

	"ocm.software/open-component-model/bindings/go/generator/universe"
)

type Schema struct {
	Schema      string `json:"$schema,omitempty"`
	Comment     string `json:"$comment,omitempty"`
	ID          string `json:"$id,omitempty"`
	Title       string `json:"title,omitempty"`
	Type        string `json:"type,omitempty"`
	Deprecated  *bool  `json:"deprecated,omitempty"`
	Ref         string `json:"$ref,omitempty"`
	Description string `json:"description,omitempty"`
	Pattern     string `json:"pattern,omitempty"`

	Properties map[string]*Schema `json:"properties,omitempty"`
	Items      *Schema            `json:"items,omitempty"`
	Required   []string           `json:"required,omitempty"`

	AdditionalProperties *SchemaOrBool      `json:"additionalProperties,omitempty"`
	Defs                 map[string]*Schema `json:"$defs,omitempty"`
}

type SchemaOrBool struct {
	Schema *Schema `json:"schema,omitempty"`
	Bool   *bool   `json:"bool,omitempty"`
}

func (sb SchemaOrBool) MarshalJSON() ([]byte, error) {
	if sb.Bool != nil {
		return json.Marshal(*sb.Bool)
	}
	return json.Marshal(sb.Schema)
}

///////////////////////////////////////////////////////////////////////////////
// Builtin runtime schemas
///////////////////////////////////////////////////////////////////////////////

func (g *Generator) builtinRuntimeRaw() *Schema {
	return &Schema{
		Schema:      "https://json-schema.org/draft/2020-12/schema",
		Comment:     "this core runtime schema was automatically included by the ocm schema generation tool to allow introspection",
		ID:          "ocm.software/open-component-model/bindings/go/runtime/schemas/Raw.schema.json",
		Title:       "Raw",
		Description: "Raw is used to hold extensions that dynamically define behavior at runtime",
		Type:        "object",
		Properties: map[string]*Schema{
			"type": {Ref: "#/$defs/runtime.Type"},
		},
		Required:             []string{"type"},
		AdditionalProperties: &SchemaOrBool{Bool: boolPtr(true)},
	}
}

func (g *Generator) builtinRuntimeType() *Schema {
	return &Schema{
		Schema:      "https://json-schema.org/draft/2020-12/schema",
		Comment:     "this core runtime schema was automatically included by the ocm schema generation tool to allow introspection",
		ID:          "ocm.software/open-component-model/bindings/go/runtime/schemas/Type.schema.json",
		Title:       "Type",
		Description: "Type represents a structured type with an optional version and a name. It is used to identify the type of an object in a versioned API.",
		Type:        "string",
		Pattern:     `^([a-zA-Z0-9][a-zA-Z0-9.]*)(?:/(v[0-9]+(?:alpha[0-9]+|beta[0-9]+)?))?$`,
	}
}

///////////////////////////////////////////////////////////////////////////////
// Root schema builder (structs OR alias types)
///////////////////////////////////////////////////////////////////////////////

func (g *Generator) buildRootSchema(ti *universe.TypeInfo) *Schema {
	if universe.IsRuntimeRaw(ti) {
		return g.builtinRuntimeRaw()
	}
	if universe.IsRuntimeType(ti) {
		return g.builtinRuntimeType()
	}

	// ---------- CASE 1: struct ----------
	if ti.Struct != nil {
		desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)

		sch := &Schema{
			Schema:               "https://json-schema.org/draft/2020-12/schema",
			Comment:              "generated by the ocm schema generation tool",
			ID:                   g.schemaID(ti),
			Title:                ti.Key.TypeName,
			Description:          desc,
			Type:                 "object",
			Properties:           g.buildStructProperties(ti.Struct, ti),
			Required:             g.buildStructRequired(ti.Struct),
			AdditionalProperties: &SchemaOrBool{Bool: boolPtr(false)},
		}

		if deprecated {
			sch.Deprecated = boolPtr(true)
		}
		return sch
	}

	// ---------- CASE 2: alias type ----------
	return g.buildAliasSchema(ti)
}

func (g *Generator) buildAliasSchema(ti *universe.TypeInfo) *Schema {
	desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)

	switch t := ti.Expr.(type) {

	case *ast.Ident: // type Foo string
		if prim := primitiveSchema(t.Name); prim != nil {
			s := &Schema{
				Schema:      "https://json-schema.org/draft/2020-12/schema",
				Comment:     "generated by the ocm schema generation tool",
				ID:          g.schemaID(ti),
				Title:       ti.Key.TypeName,
				Description: desc,
				Type:        prim.Type,
			}
			if deprecated {
				s.Deprecated = boolPtr(true)
			}
			// (optional future) enum extraction
			return s
		}

	case *ast.ArrayType: // type Foo []Bar
		return &Schema{
			Schema:  "https://json-schema.org/draft/2020-12/schema",
			Comment: "generated by the ocm schema generation tool",
			ID:      g.schemaID(ti),
			Title:   ti.Key.TypeName,
			Type:    "array",
			Items:   g.schemaForExpr(t.Elt, ti),
		}

	case *ast.MapType: // type Foo map[string]Bar
		return &Schema{
			Schema:  "https://json-schema.org/draft/2020-12/schema",
			Comment: "generated by the ocm schema generation tool",
			ID:      g.schemaID(ti),
			Title:   ti.Key.TypeName,
			Type:    "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: g.schemaForExpr(t.Value, ti),
			},
		}
	}

	// fallback
	return anyObjectSchema()
}

///////////////////////////////////////////////////////////////////////////////
// Properties
///////////////////////////////////////////////////////////////////////////////

func (g *Generator) buildStructProperties(st *ast.StructType, ti *universe.TypeInfo) map[string]*Schema {
	props := map[string]*Schema{}

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		jsonName := jsonTagName(field, field.Names[0].Name)
		if jsonName == "-" {
			continue
		}

		sch := g.schemaForExpr(field.Type, ti)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = boolPtr(true)
		}

		props[jsonName] = sch
	}

	return props
}

func (g *Generator) buildStructRequired(st *ast.StructType) []string {
	var req []string
	for _, f := range st.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		if !jsonTagHasOmitEmpty(f) {
			req = append(req, jsonTagName(f, f.Names[0].Name))
		}
	}
	return req
}

///////////////////////////////////////////////////////////////////////////////
// Expression dispatcher
///////////////////////////////////////////////////////////////////////////////

func (g *Generator) schemaForExpr(expr ast.Expr, ctx *universe.TypeInfo) *Schema {
	switch t := expr.(type) {

	case *ast.Ident:
		return g.schemaForIdent(t, ctx)

	case *ast.SelectorExpr:
		return g.schemaForSelector(t, ctx)

	case *ast.StarExpr:
		return g.schemaForExpr(t.X, ctx)

	case *ast.ArrayType:
		return &Schema{
			Type:  "array",
			Items: g.schemaForExpr(t.Elt, ctx),
		}

	case *ast.MapType:
		return &Schema{
			Type: "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: g.schemaForExpr(t.Value, ctx),
			},
		}

	case *ast.StructType:
		return g.inlineAnonymousStruct(t, ctx)

	default:
		return anyObjectSchema()
	}
}

func (g *Generator) schemaForIdent(id *ast.Ident, ctx *universe.TypeInfo) *Schema {
	// named types in universe â†’ $ref
	if ti, ok := g.U.ResolveIdent(ctx.FilePath, ctx.Key.PkgPath, id); ok {
		return &Schema{Ref: "#/$defs/" + universe.Definition(ti.Key)}
	}

	if prim := primitiveSchema(id.Name); prim != nil {
		return prim
	}

	return anyObjectSchema()
}

func (g *Generator) schemaForSelector(sel *ast.SelectorExpr, ctx *universe.TypeInfo) *Schema {
	if ti, ok := g.U.ResolveSelector(ctx.FilePath, sel); ok {
		return &Schema{Ref: "#/$defs/" + universe.Definition(ti.Key)}
	}
	return anyObjectSchema()
}

///////////////////////////////////////////////////////////////////////////////
// Reachable types for defs
///////////////////////////////////////////////////////////////////////////////

func (g *Generator) collectReachableQueue(root *universe.TypeInfo) []*universe.TypeInfo {
	seen := map[universe.TypeKey]bool{}
	var out []*universe.TypeInfo

	var walk func(*universe.TypeInfo)
	walk = func(ti *universe.TypeInfo) {
		if seen[ti.Key] {
			return
		}
		seen[ti.Key] = true

		// root is NOT included
		if ti != root {
			out = append(out, ti)
		}

		// follow fields only if struct
		if ti.Struct != nil {
			for _, f := range ti.Struct.Fields.List {
				g.collectFromExpr(f.Type, ti, walk)
			}
		} else {
			// alias types also need traversal
			g.collectFromExpr(ti.Expr, ti, walk)
		}
	}

	walk(root)
	return out
}

func (g *Generator) collectFromExpr(expr ast.Expr, ctx *universe.TypeInfo, walk func(*universe.TypeInfo)) {
	switch t := expr.(type) {

	case *ast.Ident:
		if ti, ok := g.U.ResolveIdent(ctx.FilePath, ctx.Key.PkgPath, t); ok {
			walk(ti)
		}

	case *ast.SelectorExpr:
		if ti, ok := g.U.ResolveSelector(ctx.FilePath, t); ok {
			walk(ti)
		}

	case *ast.StarExpr:
		g.collectFromExpr(t.X, ctx, walk)

	case *ast.ArrayType:
		g.collectFromExpr(t.Elt, ctx, walk)

	case *ast.MapType:
		g.collectFromExpr(t.Value, ctx, walk)

	case *ast.StructType:
		for _, f := range t.Fields.List {
			g.collectFromExpr(f.Type, ctx, walk)
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// Anonymous struct
///////////////////////////////////////////////////////////////////////////////

func (g *Generator) inlineAnonymousStruct(st *ast.StructType, ctx *universe.TypeInfo) *Schema {
	props := map[string]*Schema{}
	var req []string

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		jsonName := jsonTagName(field, field.Names[0].Name)
		if jsonName == "-" {
			continue
		}

		sch := g.schemaForExpr(field.Type, ctx)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = boolPtr(true)
		}

		props[jsonName] = sch

		if !jsonTagHasOmitEmpty(field) {
			req = append(req, jsonName)
		}
	}

	return &Schema{
		Type:                 "object",
		Properties:           props,
		Required:             req,
		AdditionalProperties: &SchemaOrBool{Bool: boolPtr(false)},
	}
}

func (g *Generator) schemaID(ti *universe.TypeInfo) string {
	return ti.Key.PkgPath + "/schemas/" + ti.Key.TypeName + ".schema.json"
}

func primitiveSchema(name string) *Schema {
	switch name {
	case "string":
		return &Schema{Type: "string"}
	case "bool":
		return &Schema{Type: "boolean"}
	case "int", "int32", "int64":
		return &Schema{Type: "integer"}
	case "float32", "float64":
		return &Schema{Type: "number"}
	}
	return nil
}

func anyObjectSchema() *Schema {
	return &Schema{
		Type:                 "object",
		AdditionalProperties: &SchemaOrBool{Bool: boolPtr(true)},
	}
}

func boolPtr(v bool) *bool { return &v }

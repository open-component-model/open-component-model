package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

///////////////////////////////////////////////////////////////////////////
// Logging
///////////////////////////////////////////////////////////////////////////

var logLevel slog.LevelVar

var Logger = slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
	Level: &logLevel,
}))

func init() {
	switch strings.ToLower(os.Getenv("LOG_LEVEL")) {
	case "debug":
		logLevel.Set(slog.LevelDebug)
	case "warn":
		logLevel.Set(slog.LevelWarn)
	case "error":
		logLevel.Set(slog.LevelError)
	default:
		logLevel.Set(slog.LevelInfo)
	}
}

///////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////

const (
	marker           = "+ocm:jsonschema-gen=true"
	SchemaDir        = "schemas"
	outputGo         = "zz_generated.ocm_jsonschema.go"
	DefaultSchemaURI = "https://json-schema.org/draft/2020-12/schema"

	RuntimeRawID  = "ocm.software/open-component-model/bindings/go/runtime/schemas/Raw.json"
	RuntimeRawDef = "runtime.Raw"

	RuntimeTypeID  = "ocm.software/open-component-model/bindings/go/runtime/schemas/Type.json"
	RuntimeTypeDef = "runtime.Type"

	runtimeTypePattern = `^([a-zA-Z0-9][a-zA-Z0-9.]*)(?:/(v[0-9]+(?:alpha[0-9]+|beta[0-9]+)?))?$`

	RootComment          = "generated by the ocm schema generation tool"
	AutoGeneratedComment = "this core runtime schema was automatically included by the ocm schema generation tool to allow introspection"
)

///////////////////////////////////////////////////////////////////////////
// JSON Schema Model
///////////////////////////////////////////////////////////////////////////

type Schema struct {
	Schema      string `json:"$schema,omitempty"`
	Comment     string `json:"$comment,omitempty"`
	ID          string `json:"$id,omitempty"`
	Ref         string `json:"$ref,omitempty"`
	Title       string `json:"title,omitempty"`
	Description string `json:"description,omitempty"`
	Type        string `json:"type,omitempty"`
	Deprecated  *bool  `json:"deprecated,omitempty"`

	Properties map[string]*Schema `json:"properties,omitempty"`
	Items      *Schema            `json:"items,omitempty"`
	Required   []string           `json:"required,omitempty"`

	AdditionalProperties *SchemaOrBool `json:"additionalProperties,omitempty"`
	Pattern              string        `json:"pattern,omitempty"`

	Defs map[string]*Schema `json:"$defs,omitempty"`
}

var AnyObject = Schema{Type: "object", AdditionalProperties: &SchemaOrBool{Bool: ptr(true)}}

// DeepCopy returns a deep copy of the Schema.
func (in *Schema) DeepCopy() *Schema {
	if in == nil {
		return nil
	}

	out := new(Schema)

	out.Schema = in.Schema
	out.Comment = in.Comment
	out.ID = in.ID
	out.Ref = in.Ref
	out.Title = in.Title
	out.Description = in.Description
	out.Type = in.Type

	if in.Deprecated != nil {
		v := *in.Deprecated
		out.Deprecated = &v
	}

	if in.Properties != nil {
		out.Properties = make(map[string]*Schema, len(in.Properties))
		for k, v := range in.Properties {
			out.Properties[k] = v.DeepCopy()
		}
	}

	if in.Items != nil {
		out.Items = in.Items.DeepCopy()
	}

	if in.Required != nil {
		out.Required = make([]string, len(in.Required))
		copy(out.Required, in.Required)
	}

	if in.AdditionalProperties != nil {
		out.AdditionalProperties = in.AdditionalProperties.DeepCopy()
	}

	out.Pattern = in.Pattern

	if in.Defs != nil {
		out.Defs = make(map[string]*Schema, len(in.Defs))
		for k, v := range in.Defs {
			out.Defs[k] = v.DeepCopy()
		}
	}

	return out
}

type SchemaOrBool struct {
	Schema *Schema `json:"schema,omitempty"`
	Bool   *bool   `json:"bool,omitempty"`
}

func (sb *SchemaOrBool) DeepCopy() *SchemaOrBool {
	if sb.Schema == nil {
		return &SchemaOrBool{Bool: sb.Bool}
	}
	return &SchemaOrBool{Schema: sb.Schema.DeepCopy()}
}

func (sb SchemaOrBool) MarshalJSON() ([]byte, error) {
	if sb.Bool != nil {
		return json.Marshal(*sb.Bool)
	}
	return json.Marshal(sb.Schema)
}

func (sb *SchemaOrBool) UnmarshalJSON(b []byte) error {
	t := strings.TrimSpace(string(b))

	switch t {
	case "true":
		sb.Bool = ptr(true)
		sb.Schema = nil
		return nil
	case "false":
		sb.Bool = ptr(false)
		sb.Schema = nil
		return nil
	case "null":
		sb.Bool = nil
		sb.Schema = nil
		return nil
	default:
		var obj Schema
		if err := json.Unmarshal(b, &obj); err != nil {
			return fmt.Errorf("invalid SchemaOrBool JSON: %q", t)
		}
		sb.Bool = nil
		sb.Schema = &obj
		return nil
	}
}

func ptr[T any](v T) *T { return &v }

///////////////////////////////////////////////////////////////////////////
// Struct Info
///////////////////////////////////////////////////////////////////////////

type StructInfo struct {
	PkgPath     string
	PkgName     string
	TypeName    string
	File        string
	Node        *ast.StructType
	TypeComment string
}

///////////////////////////////////////////////////////////////////////////
// Global Registry for Named Struct Schemas Only
///////////////////////////////////////////////////////////////////////////

var namedSchemas = map[string]*Schema{}
var namedInfos = map[string]StructInfo{}

func makeSchemaID(pkgPath, typeName string) string {
	return fmt.Sprintf("%s/%s/%s.schema.json", pkgPath, SchemaDir, typeName)
}

// Lookup struct by type name (unique because we use full pkg path + name)
func lookupStruct(name string) (StructInfo, bool) {
	for _, si := range namedInfos {
		if si.TypeName == name {
			return si, true
		}
	}
	return StructInfo{}, false
}

///////////////////////////////////////////////////////////////////////////
// Annotated Struct Discovery
///////////////////////////////////////////////////////////////////////////

func FindAnnotatedStructs(root string) ([]StructInfo, error) {
	var out []StructInfo

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return err
		}
		if !strings.HasSuffix(path, ".go") ||
			strings.HasSuffix(path, "_test.go") ||
			strings.HasPrefix(filepath.Base(path), "zz_generated") {
			return nil
		}

		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		pkgPath, _ := getImportPath(filepath.Dir(path))

		for _, decl := range file.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, spec := range gd.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if !hasMarker(gd.Doc, ts.Doc) {
					continue
				}
				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				comment := findStructComment(ts, gd)

				si := StructInfo{
					PkgPath:     pkgPath,
					PkgName:     file.Name.Name,
					TypeName:    ts.Name.Name,
					File:        path,
					Node:        st,
					TypeComment: comment,
				}

				key := pkgPath + "." + si.TypeName
				namedInfos[key] = si
				out = append(out, si)
			}
		}

		return nil
	})

	return out, err
}

///////////////////////////////////////////////////////////////////////////
// Marker + Comments
///////////////////////////////////////////////////////////////////////////

func hasMarker(groups ...*ast.CommentGroup) bool {
	for _, g := range groups {
		if g == nil {
			continue
		}
		for _, c := range g.List {
			if strings.Contains(c.Text, marker) {
				return true
			}
		}
	}
	return false
}

func extractCommentText(cg *ast.CommentGroup) string {
	if cg == nil {
		return ""
	}

	var out []string
	for _, c := range cg.List {
		line := strings.TrimSpace(strings.TrimPrefix(c.Text, "//"))
		line = strings.TrimSpace(strings.TrimPrefix(line, "/*"))
		line = strings.TrimSpace(strings.TrimSuffix(line, "*/"))

		// Skip internal markers
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "+") {
			continue
		}

		// NEW: ignore any nolint comments
		// examples:
		//   //nolint
		//   // nolint
		//   //nolint:unique,gosec
		if strings.HasPrefix(strings.ToLower(line), "nolint") ||
			strings.HasPrefix(strings.ToLower(line), "//nolint") {
			continue
		}

		out = append(out, line)
	}

	return strings.Join(out, "\n")
}

func findFieldComment(f *ast.Field) string {
	return extractCommentText(f.Doc)
}

func findStructComment(ts *ast.TypeSpec, gd *ast.GenDecl) string {
	if ts.Doc != nil {
		return extractCommentText(ts.Doc)
	}
	return extractCommentText(gd.Doc)
}

func isDeprecatedComment(c string) bool {
	lc := strings.ToLower(c)
	return strings.Contains(lc, "deprecated:") ||
		strings.Contains(lc, "@deprecated")
}

///////////////////////////////////////////////////////////////////////////
// Import Path Resolution
///////////////////////////////////////////////////////////////////////////

func getImportPath(folder string) (string, error) {
	abs, _ := filepath.Abs(folder)
	dir := abs

	for {
		goMod := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(goMod); err == nil {
			module, _ := readModulePath(goMod)
			rel, _ := filepath.Rel(dir, abs)
			if rel == "." {
				return module, nil
			}
			return filepath.ToSlash(filepath.Join(module, rel)), nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", errors.New("go.mod not found")
}

func readModulePath(path string) (string, error) {
	f, _ := os.Open(path)
	defer f.Close()

	sc := bufio.NewScanner(f)
	for sc.Scan() {
		line := strings.TrimSpace(sc.Text())
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}
	return "", errors.New("module path not found")
}

///////////////////////////////////////////////////////////////////////////
// Primitive Type Mapping
///////////////////////////////////////////////////////////////////////////

func primitiveSchema(name string) *Schema {
	switch name {
	case "string":
		return &Schema{Type: "string"}
	case "bool":
		return &Schema{Type: "boolean"}
	case "int", "int32", "int64":
		return &Schema{Type: "integer"}
	case "float32", "float64":
		return &Schema{Type: "number"}
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////
// Special Runtime Types
///////////////////////////////////////////////////////////////////////////

func isRuntimeType(sel *ast.SelectorExpr) bool {
	id, ok := sel.X.(*ast.Ident)
	return ok && id.Name == "runtime" && sel.Sel.Name == "Type"
}

func isRuntimeRaw(star *ast.StarExpr) bool {
	sel, ok := star.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	id, ok := sel.X.(*ast.Ident)
	return ok && id.Name == "runtime" && sel.Sel.Name == "Raw"
}

///////////////////////////////////////////////////////////////////////////
// Core: Generate Schema for a Named Struct (unbundled)
///////////////////////////////////////////////////////////////////////////

func GenerateSchemaForNamed(info StructInfo) *Schema {
	schemaID := makeSchemaID(info.PkgPath, info.TypeName)

	root := &Schema{
		Comment:              RootComment,
		Schema:               DefaultSchemaURI,
		ID:                   schemaID,
		Title:                info.TypeName,
		Description:          info.TypeComment,
		Type:                 "object",
		Properties:           map[string]*Schema{},
		Required:             []string{},
		AdditionalProperties: &SchemaOrBool{Bool: ptr(false)},
	}

	// Fill properties from struct fields
	for _, field := range info.Node.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		name := field.Names[0].Name
		tag := parseJSONTag(field)
		if tag == "-" {
			continue
		}

		jsonName := name
		if tag != "" {
			jsonName = tag
		}

		prop := schemaForType(field.Type)

		// Field comment → description
		if c := findFieldComment(field); c != "" {
			prop.Description = c
			if isDeprecatedComment(c) {
				prop.Deprecated = ptr(true)
			}
		}

		root.Properties[jsonName] = prop

		if !jsonTagHasOmitEmpty(field) {
			root.Required = append(root.Required, jsonName)
		}
	}

	return root
}

///////////////////////////////////////////////////////////////////////////
// Field Type → Schema (anonymous fully inline, named via $ref)
///////////////////////////////////////////////////////////////////////////

func schemaForType(expr ast.Expr) *Schema {
	switch t := expr.(type) {
	//--------------------------------------------------------------
	// Primitive identifiers (string, int, ...)
	//--------------------------------------------------------------
	case *ast.Ident:
		if prim := primitiveSchema(t.Name); prim != nil {
			return prim
		}

		// Named struct?
		if si, ok := lookupStruct(t.Name); ok {
			// Use $ref into $defs
			sch := &Schema{Ref: "#/$defs/" + si.TypeName}
			// mark deprecation on referenced named type
			if isDeprecatedComment(si.TypeComment) {
				sch.Deprecated = ptr(true)
			}
			return sch
		}

		// Unknown identifier → loose object
		return AnyObject.DeepCopy()

	//--------------------------------------------------------------
	// Pointers
	//--------------------------------------------------------------
	case *ast.StarExpr:
		if isRuntimeRaw(t) {
			// Instead of absolute schema ID → local $defs ref
			return &Schema{Ref: "#/$defs/" + RuntimeRawDef}
		}
		return schemaForType(t.X)

	//--------------------------------------------------------------
	// Arrays
	//--------------------------------------------------------------
	case *ast.ArrayType:
		return &Schema{
			Type:  "array",
			Items: schemaForType(t.Elt),
		}

	//--------------------------------------------------------------
	// Maps
	//--------------------------------------------------------------
	case *ast.MapType:
		valueSchema := schemaForType(t.Value)
		return &Schema{
			Type: "object",
			AdditionalProperties: &SchemaOrBool{
				Schema: valueSchema,
			},
		}

	//--------------------------------------------------------------
	// SelectorExpr (runtime.Type)
	//--------------------------------------------------------------
	case *ast.SelectorExpr:
		if isRuntimeType(t) {
			return &Schema{Ref: "#/$defs/" + RuntimeTypeDef}
		}
		return &Schema{Type: "object"}

	//--------------------------------------------------------------
	// Anonymous struct — fully inline
	//--------------------------------------------------------------
	case *ast.StructType:
		return inlineAnonymousStruct(t)

	//--------------------------------------------------------------
	default:
		return AnyObject.DeepCopy()
	}
}

///////////////////////////////////////////////////////////////////////////
// Inline Anonymous Struct Generation (unlimited nesting!)
///////////////////////////////////////////////////////////////////////////

func inlineAnonymousStruct(st *ast.StructType) *Schema {
	out := &Schema{
		Type:                 "object",
		Properties:           map[string]*Schema{},
		Required:             []string{},
		AdditionalProperties: &SchemaOrBool{Bool: ptr(false)},
	}

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		fName := field.Names[0].Name
		tag := parseJSONTag(field)
		if tag == "-" {
			continue
		}

		jsonName := fName
		if tag != "" {
			jsonName = tag
		}

		prop := schemaForType(field.Type)

		if c := findFieldComment(field); c != "" {
			prop.Description = c
		}

		out.Properties[jsonName] = prop

		if !jsonTagHasOmitEmpty(field) {
			out.Required = append(out.Required, jsonName)
		}
	}

	return out
}

///////////////////////////////////////////////////////////////////////////
// JSON Tag Helpers
///////////////////////////////////////////////////////////////////////////

func parseJSONTag(f *ast.Field) string {
	if f.Tag == nil {
		return ""
	}
	tag := strings.Trim(f.Tag.Value, "`")
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, `json:"`) {
			val := strings.TrimPrefix(part, `json:"`)
			val = strings.TrimSuffix(val, `"`)
			return strings.Split(val, ",")[0]
		}
	}
	return ""
}

func jsonTagHasOmitEmpty(f *ast.Field) bool {
	if f.Tag == nil {
		return false
	}
	tag := strings.Trim(f.Tag.Value, "`")
	for _, part := range strings.Split(tag, " ") {
		if !strings.HasPrefix(part, `json:"`) {
			continue
		}
		content := strings.TrimSuffix(strings.TrimPrefix(part, `json:"`), `"`)
		parts := strings.Split(content, ",")
		for _, p := range parts[1:] {
			if p == "omitempty" {
				return true
			}
		}
	}
	return false
}

///////////////////////////////////////////////////////////////////////////
// Runtime Raw Detection
///////////////////////////////////////////////////////////////////////////

func usesRuntimeRaw(s *Schema) bool {
	if s == nil {
		return false
	}

	// Direct reference
	if s.Ref == "#/$defs/"+RuntimeRawDef {
		return true
	}

	// Properties
	for _, p := range s.Properties {
		if usesRuntimeRaw(p) {
			return true
		}
	}

	// Items
	if s.Items != nil && usesRuntimeRaw(s.Items) {
		return true
	}

	// additionalProperties
	if s.AdditionalProperties != nil && s.AdditionalProperties.Schema != nil {
		if usesRuntimeRaw(s.AdditionalProperties.Schema) {
			return true
		}
	}

	// defs (for named schemas only)
	for _, d := range s.Defs {
		if usesRuntimeRaw(d) {
			return true
		}
	}

	return false
}

func usesRuntimeType(s *Schema) bool {
	if s == nil {
		return false
	}
	if s.Ref == "#/$defs/"+RuntimeTypeDef {
		return true
	}
	for _, p := range s.Properties {
		if usesRuntimeType(p) {
			return true
		}
	}
	if s.Items != nil && usesRuntimeType(s.Items) {
		return true
	}
	if s.AdditionalProperties != nil && s.AdditionalProperties.Schema != nil {
		if usesRuntimeType(s.AdditionalProperties.Schema) {
			return true
		}
	}
	for _, d := range s.Defs {
		if usesRuntimeType(d) {
			return true
		}
	}
	return false
}

///////////////////////////////////////////////////////////////////////////
// Build $defs for a Named Root Schema
///////////////////////////////////////////////////////////////////////////

func buildDefsForRoot(rootInfo StructInfo) map[string]*Schema {
	defs := map[string]*Schema{}

	// Collect all reachable named types from this root
	reachable := collectReachableNamed(rootInfo)

	// Add reachable named types except the root itself
	for _, si := range reachable {
		if si.TypeName == rootInfo.TypeName && si.PkgPath == rootInfo.PkgPath {
			continue // never include the root in $defs
		}
		id := makeSchemaID(si.PkgPath, si.TypeName)
		if schema := namedSchemas[id]; schema != nil {
			defs[si.TypeName] = schema.DeepCopy()
		}
	}

	// Determine if *any* reachable type uses runtime.Raw
	needsRaw := false
	for _, si := range reachable {
		id := makeSchemaID(si.PkgPath, si.TypeName)
		if schema := namedSchemas[id]; schema != nil {
			if usesRuntimeRaw(schema) {
				needsRaw = true
				break
			}
		}
	}

	// Add runtime.Raw only if needed
	if needsRaw {
		if raw := namedSchemas[RuntimeRawID]; raw != nil {
			defs[RuntimeRawDef] = raw.DeepCopy()
		}
	}

	needsRuntimeType := false
	for _, si := range reachable {
		id := makeSchemaID(si.PkgPath, si.TypeName)
		if schema := namedSchemas[id]; schema != nil {
			if usesRuntimeType(schema) {
				needsRuntimeType = true
				break
			}
		}
	}
	if needsRuntimeType {
		if t := namedSchemas[RuntimeTypeID]; t != nil {
			defs[RuntimeTypeDef] = t.DeepCopy()
		}
	}

	return defs
}

///////////////////////////////////////////////////////////////////////////
// Collect reachable *named* struct types recursively
///////////////////////////////////////////////////////////////////////////

func collectReachableNamed(root StructInfo) []StructInfo {
	seen := map[string]bool{}
	var out []StructInfo

	var walk func(StructInfo)
	walk = func(si StructInfo) {
		key := si.PkgPath + "." + si.TypeName
		if seen[key] {
			return
		}
		seen[key] = true
		out = append(out, si)

		for _, field := range si.Node.Fields.List {
			collectNamedTypesInExpr(field.Type, func(name string) {
				if nested, ok := lookupStruct(name); ok {
					walk(nested)
				}
			})
		}
	}

	walk(root)
	return out
}

///////////////////////////////////////////////////////////////////////////
// Collect named types mentioned inside a type expression
///////////////////////////////////////////////////////////////////////////

func collectNamedTypesInExpr(expr ast.Expr, fn func(name string)) {
	switch t := expr.(type) {
	case *ast.Ident:
		fn(t.Name)
	case *ast.SelectorExpr:
		// Only last part can be type name
		fn(t.Sel.Name)
	case *ast.StarExpr:
		collectNamedTypesInExpr(t.X, fn)
	case *ast.ArrayType:
		collectNamedTypesInExpr(t.Elt, fn)
	case *ast.MapType:
		collectNamedTypesInExpr(t.Value, fn)
	case *ast.StructType:
		for _, f := range t.Fields.List {
			collectNamedTypesInExpr(f.Type, fn)
		}
	}
}

///////////////////////////////////////////////////////////////////////////
// Finalize root schema: attach $defs with all reachable named schemas
///////////////////////////////////////////////////////////////////////////

func finalizeSchema(root *Schema, info StructInfo) *Schema {
	if root == nil {
		return nil
	}

	defs := buildDefsForRoot(info)
	if len(defs) > 0 {
		root.Defs = defs
	}

	return root
}

///////////////////////////////////////////////////////////////////////////
// Schema Output Writer
///////////////////////////////////////////////////////////////////////////

func WriteSchemaJSON(info StructInfo, schema *Schema) error {
	if schema == nil {
		return nil
	}

	// Attach $defs for this root schema
	schema = finalizeSchema(schema, info)

	outDir := filepath.Join(filepath.Dir(info.File), SchemaDir)
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	raw, err := json.MarshalIndent(schema, "", "  ")
	if err != nil {
		return err
	}

	outPath := filepath.Join(outDir, info.TypeName+".schema.json")

	//nolint:gosec // we're writing to a file that we control with our generators, this is fine
	if err := os.WriteFile(outPath, raw, 0o644); err != nil {
		return err
	}

	return nil
}

// /////////////////////////////////////////////////////////////////////////
// Embedding for go:embed (per module)
// /////////////////////////////////////////////////////////////////////////

func WriteEmbedFileForPackage(info StructInfo) error {
	pkgDir := filepath.Dir(info.File)
	outPath := filepath.Join(pkgDir, outputGo)

	var typesInPkg []StructInfo
	for _, si := range namedInfos {
		if filepath.Dir(si.File) == pkgDir {
			typesInPkg = append(typesInPkg, si)
		}
	}
	sort.Slice(typesInPkg, func(i, j int) bool {
		return typesInPkg[i].TypeName < typesInPkg[j].TypeName
	})

	// Build file in memory
	var buf bytes.Buffer

	fmt.Fprintf(&buf, `//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by jsonschemagen. DO NOT EDIT.

package %s

import (
	_ "embed"
)
`, info.PkgName)

	for _, si := range typesInPkg {
		fmt.Fprintf(&buf, `
//go:embed schemas/%[1]s.schema.json
var schema%[1]s []byte
`, si.TypeName)
	}

	for _, si := range typesInPkg {
		fmt.Fprintf(&buf, `
// JSONSchema returns the JSON Schema for %[1]s.
func (%[1]s) JSONSchema() []byte {
	return schema%[1]s
}
`, si.TypeName)
	}

	// Run gofmt to enforce deterministic formatting
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting failed: %w", err)
	}

	return os.WriteFile(outPath, formatted, 0o644)
}

///////////////////////////////////////////////////////////////////////////
// Runtime Raw Built-in Schema
///////////////////////////////////////////////////////////////////////////

func ensureRuntimeRawSchema() {
	if _, ok := namedSchemas[RuntimeRawID]; ok {
		return
	}

	raw := &Schema{
		Comment:     AutoGeneratedComment,
		Schema:      DefaultSchemaURI,
		ID:          RuntimeRawID,
		Description: "Raw is used to hold extensions that dynamically define behavior at runtime",
		Type:        "object",
		Properties: map[string]*Schema{
			"type": {
				Ref: "#/$defs/" + RuntimeTypeDef,
			},
		},
		Required:             []string{"type"},
		AdditionalProperties: &SchemaOrBool{Bool: ptr(true)},
	}

	namedSchemas[RuntimeRawID] = raw
}

func ensureRuntimeTypeSchema() {
	if _, ok := namedSchemas[RuntimeTypeID]; ok {
		return
	}

	t := &Schema{
		Comment:     AutoGeneratedComment,
		Schema:      DefaultSchemaURI,
		ID:          RuntimeTypeID,
		Description: "Type represents a structured type with an optional version and a name. It is used to identify the type of an object in a versioned API.",
		Type:        "string",
		Pattern:     runtimeTypePattern,
	}

	namedSchemas[RuntimeTypeID] = t
}

///////////////////////////////////////////////////////////////////////////
// Module discovery
///////////////////////////////////////////////////////////////////////////

func findAllModules(root string) ([]string, error) {
	var modules []string

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if filepath.Base(path) == "go.mod" {
			modules = append(modules, filepath.Dir(path))
		}
		return nil
	})

	return modules, err
}

///////////////////////////////////////////////////////////////////////////
// Main Program
///////////////////////////////////////////////////////////////////////////

func main() {
	if len(os.Args) < 2 {
		Logger.Error("Usage: jsonschemagen <root-dir>")
		os.Exit(1)
	}

	root := os.Args[1]

	// RuntimeRaw must be available before anything else
	ensureRuntimeRawSchema()
	ensureRuntimeTypeSchema()

	// Discover modules
	modules, err := findAllModules(root)
	if err != nil {
		Logger.Error("module discovery error", "error", err)
		os.Exit(1)
	}
	if len(modules) == 0 {
		Logger.Error("No go.mod files found", "root", root)
		os.Exit(1)
	}

	// Collect annotated structs across all modules
	var allInfos []StructInfo
	for _, mod := range modules {
		infos, err := FindAnnotatedStructs(mod)
		if err != nil {
			Logger.Error("scan error", "module", mod, "error", err)
			os.Exit(1)
		}
		allInfos = append(allInfos, infos...)
	}

	if len(allInfos) == 0 {
		Logger.Info("No annotated types found")
		return
	}

	// Generate unbundled schemas for named structs
	for _, info := range allInfos {
		s := GenerateSchemaForNamed(info)
		namedSchemas[s.ID] = s
	}

	// Write bundled schemas to disk
	for _, info := range allInfos {
		id := makeSchemaID(info.PkgPath, info.TypeName)
		s := namedSchemas[id]
		if s == nil {
			Logger.Error("missing schema for type", "type", info.TypeName)
			continue
		}

		if err := WriteSchemaJSON(info, s); err != nil {
			Logger.Error("write schema error", "type", info.TypeName, "error", err)
		}
	}

	// Track packages we already wrote an embed file for
	written := map[string]bool{}

	pkgDirs := make([]string, 0)
	for _, si := range allInfos {
		d := filepath.Dir(si.File)
		if !written[d] {
			pkgDirs = append(pkgDirs, d)
			written[d] = true
		}
	}
	sort.Strings(pkgDirs)

	for _, pkg := range pkgDirs {
		// find any StructInfo in this package
		var si StructInfo
		for _, s := range allInfos {
			if filepath.Dir(s.File) == pkg {
				si = s
				break
			}
		}
		if err := WriteEmbedFileForPackage(si); err != nil {
			Logger.Error("embed file error", "package", pkg, "error", err)
		}
	}
}

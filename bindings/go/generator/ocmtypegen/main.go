package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// GenerateGetTypeMethod generates a GetType method for structs embedding Type
func GenerateGetTypeMethod(structName string) string {
	return fmt.Sprintf(`import (
	"ocm.software/open-component-model/bindings/go/runtime"
)

// GetType returns the type definition of %[1]s as per OCM's Type System.
// It is the type on which it will be registered with the dynamic type system.
func (t *%[1]s) GetType() runtime.Type {
	return t.Type
}
`, structName)
}

// ParseStructsWithGenerateDirective parses Go source code and finds structs with a specific go:generate directive
func ParseStructsWithGenerateDirective(sourceFile string) (string, []string, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, sourceFile, nil, parser.AllErrors|parser.ParseComments)
	if err != nil {
		return "", nil, fmt.Errorf("failed to parse source code: %w", err)
	}

	var structNames []string

	for _, comment := range node.Comments {
		for _, c := range comment.List {
			if strings.Contains(c.Text, "ocmtypegen") {
				for _, decl := range node.Decls {
					genDecl, ok := decl.(*ast.GenDecl)
					if !ok || genDecl.Tok != token.TYPE {
						continue
					}

					for _, spec := range genDecl.Specs {
						typeSpec, ok := spec.(*ast.TypeSpec)
						if !ok {
							continue
						}

						structType, ok := typeSpec.Type.(*ast.StructType)
						if !ok {
							continue
						}

						for _, field := range structType.Fields.List {
							if !strings.Contains(field.Tag.Value, `json:"type"`) {
								continue
							}
							ident, ok := field.Type.(*ast.SelectorExpr)
							if !ok {
								return "", nil, fmt.Errorf("type expression found at %q but was not an import from runtime", typeSpec.Name.String())
							}
							if ident.Sel.Name == "type" {
								return "", nil, fmt.Errorf("type expression found at %q but was unexported", typeSpec.Name.String())
							}
							if ident.Sel.Name == "Type" {
								structNames = append(structNames, typeSpec.Name.Name)
								break
							}
						}
					}
				}
			}
		}
	}

	return node.Name.Name, structNames, nil
}

func main() {
	// Get the source file path from command-line arguments
	if len(os.Args) < 2 {
		log.Fatal("Usage: //go:generate ocmtypegen $GOFILE")
	}
	sourceFile := os.Args[1]
	outputFile := filepath.Join(filepath.Dir(sourceFile), "zz_generated.type.ocm.software.go")

	pkg, structs, err := ParseStructsWithGenerateDirective(sourceFile)
	if err != nil {
		log.Fatalf("Error parsing structs: %v", err)
	}

	if len(structs) == 0 {
		log.Println("No applicable structs found for GetType generation.")
		return
	}

	var output strings.Builder
	output.WriteString("// Code generated by ocmtypegen; DO NOT EDIT.\n\n")
	output.WriteString("package " + pkg + "\n\n")

	for _, structName := range structs {
		output.WriteString(GenerateGetTypeMethod(structName))
	}

	if err := os.WriteFile(outputFile, []byte(output.String()), 0o600); err != nil {
		log.Fatalf("Failed to write generated file: %v", err)
	}

	log.Printf("Generated file: %s\n", outputFile)
}

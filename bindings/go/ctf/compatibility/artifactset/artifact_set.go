package artifactset

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"path/filepath"

	"github.com/nlepage/go-tarfs"
	ociimagespec "github.com/opencontainers/image-spec/specs-go/v1"

	"ocm.software/open-component-model/bindings/go/blob"
	"ocm.software/open-component-model/bindings/go/ctf"
)

// MediaType is the definition of the ArtifactSet Media Type in old format CTFs
// It is generated by OCM when transferring resources into a CTF and written
// into a localBlob mediaType as an access hint:
//
//	access:
//	  localReference: sha256:e40e3a2f1ab1a98328dfd14539a79d27aff5c4d5c34cd16a85f0288bfa76490b
//	  mediaType: application/vnd.oci.image.manifest.v1+tar+gzip
//	  referenceName: jakobmoellerdev/podinfo/podinfo:6.7.1
//	  type: localBlob
//
// This MediaType can be used on artifact introspection on the resource
// together with NewArtifactSetFromBlob to access that ArtifactSet.
const MediaType = "application/vnd.oci.image.manifest.v1+tar+gzip"

// ArtifactSet is the equivalent (deprecated) implementation of
// https://github.com/open-component-model/ocm/blob/main/api/oci/extensions/repositories/artifactset
//
// NOTE: Even though it does look similar to an OCI Image Layout, it is not
// the same. Notable differences are:
//
//   - The blobs directory orders blobs in the form
//
//     blobs/digest-algo.digest
//
//     instead of
//
//     blobs/digest-algo/digest.
//
//   - The index.json file IS a valid OCI Image Index json, but does not maintain
//     the ociimagespec.AnnotationRefName correctly, instead it sets it to the version
//     of the resource. Additionally, it maintains the software.ocm/tags annotation.
//     This means it is MANDATORY to understand the resource access.referenceName
//     in place of the usual meaning of the refName to fully target an OCI Image out
//     of an ArtifactSet.
//
//   - The index.json file contains a software.ocm/main annotation, that declares
//     the main blob to be introspected (useful for single-layer artifacts or multi-layer
//     artifacts with one main layer and multiple metadata layers).
//
// Altogether, this makes the ArtifactSet a custom format that is not compatible
// with OCI Image Layouts or CTF readings that are unaware of the Component Descriptor.
//
// It is thus deprecated and should not be used anymore.
//
// This MediaType now only serves to read from old LocalBlobs and CTFs and is maintained
// to ensure compatibility.
//
// New CTFs should and will always include localBlobs not as artifact sets, but as proper
// OCI Image Layouts.
type ArtifactSet interface {
	io.Closer
	ctf.ReadOnlyBlobStore
	GetIndex() ociimagespec.Index
}

var _ ArtifactSet = (*artifactSet)(nil)

// NewArtifactSetFromBlob creates a new ArtifactSet from a blob.
// It will start owning the readcloser in the blob and needs to be closed due to this.
// It is backed by a tar filesystem that is either read from a tar file or a gzip file.
// The gzip format is not detected by MediaType, but by the magic number in the first 512 bytes of the file.
// The blob must be a valid ArtifactSet, otherwise an error is returned.
//
// The ArtifactSet mereley supports read-only and any future write operation is no longer supported.
// All ArtifactSet's encountered in the wild MUST be converted to OCI Image Layouts.
//
// See ArtifactSet for more information about the format.
func NewArtifactSetFromBlob(b blob.ReadOnlyBlob) (ArtifactSet, error) {
	// if we are media type aware, we need to check the media type.
	// otherwise we do a best effort to detect the media type.
	// TODO(jakobmoellerdev) based on media type we could immediately detect if we are gzipped or not.
	if mtAware, ok := b.(blob.MediaTypeAware); ok {
		if mt, known := mtAware.MediaType(); known && mt != MediaType {
			return nil, fmt.Errorf("unsupported media type %q, expected %q", mt, MediaType)
		}
	}

	raw, err := b.ReadCloser()
	if err != nil {
		return nil, fmt.Errorf("unable to open blob: %w", err)
	}

	// Read the first 512 bytes (Tar header size)
	buf := make([]byte, 512)
	n, err := raw.Read(buf)
	if err != nil {
		return nil, err
	}

	var reader io.Reader = raw

	closeFn := raw.Close
	// Check for Gzip magic number (0x1F, 0x8B)
	if n >= 2 && buf[0] == 0x1F && buf[1] == 0x8B {
		multiReader := io.MultiReader(bytes.NewReader(buf), raw)
		gzipReader, err := gzip.NewReader(multiReader)
		if err != nil {
			return nil, fmt.Errorf("failed to create gzip reader: %w", err)
		}
		closeFn = func() error {
			return errors.Join(gzipReader.Close(), raw.Close())
		}
		reader = gzipReader
	}

	fs, err := tarfs.New(reader)
	if err != nil {
		return nil, fmt.Errorf("unable to create tarfs: %w", err)
	}
	fileSystem := fs.(fileSystem)

	idx := ociimagespec.Index{}
	rawidx, err := fs.Open("index.json")
	if err != nil {
		return nil, fmt.Errorf("unable to open index.json: %w", err)
	}
	defer rawidx.Close()
	if err := json.NewDecoder(rawidx).Decode(&idx); err != nil {
		return nil, fmt.Errorf("unable to decode index.json: %w", err)
	}

	return &artifactSet{
		close: closeFn,
		fs:    fileSystem,
		idx:   idx,
	}, nil
}

// fileSystem is a subset of the tarfs interface that is used to
// access the tar underneath with Stat and ReadDir.
// This is needed because there is no such interface available from tarfs directly
// and tarfs itself only exposes the fs.FS interface even though it does support
// ReadDir and Stat.
type fileSystem interface {
	fs.StatFS
	fs.ReadDirFS
}

// artifactSet is the implementation of the ArtifactSet interface.
// See ArtifactSet for more information about the format.
type artifactSet struct {
	close func() error
	fs    fileSystem
	idx   ociimagespec.Index
}

func (a *artifactSet) GetIndex() ociimagespec.Index {
	return a.idx
}

func (a *artifactSet) ListBlobs() (digests []string, err error) {
	dir, err := a.fs.ReadDir(ctf.BlobsDirectoryName)
	if err != nil {
		return nil, fmt.Errorf("unable to list blobs: %w", err)
	}

	digests = make([]string, 0, len(dir))
	for _, entry := range dir {
		if entry.Type().IsRegular() {
			digests = append(digests, ctf.ToDigest(entry.Name()))
		}
	}
	return digests, nil
}

func (a *artifactSet) GetBlob(digest string) (blob.ReadOnlyBlob, error) {
	return newArtifactBlob(a.fs, digest)
}

func (a *artifactSet) Close() error {
	return a.close()
}

// ArtifactBlob is a blob.ReadOnlyBlob that is backed by an ArtifactSet.
type ArtifactBlob struct {
	fs     fileSystem
	name   string // name of the blob
	digest string
	size   int64
}

var (
	_ blob.ReadOnlyBlob = (*ArtifactBlob)(nil)
	_ blob.DigestAware  = (*ArtifactBlob)(nil)
	_ blob.SizeAware    = (*ArtifactBlob)(nil)
)

func newArtifactBlob(fs fileSystem, digest string) (blob.ReadOnlyBlob, error) {
	name := filepath.Join(ctf.BlobsDirectoryName, ctf.ToBlobFileName(digest))
	f, err := fs.Stat(name)
	if err != nil {
		return nil, fmt.Errorf("unable to stat file %q: %w", name, err)
	}
	return &ArtifactBlob{
		name:   name,
		fs:     fs,
		digest: digest,
		size:   f.Size(),
	}, nil
}

func (a *ArtifactBlob) Size() (size int64) {
	return a.size
}

func (a *ArtifactBlob) Digest() (digest string, known bool) {
	return a.digest, true
}

func (a *ArtifactBlob) ReadCloser() (io.ReadCloser, error) {
	return a.fs.Open(a.name)
}

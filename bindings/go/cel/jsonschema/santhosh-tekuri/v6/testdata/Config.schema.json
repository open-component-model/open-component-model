{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$comment": "generated by the ocm schema generation tool",
  "$id": "ocm.software/open-component-model/bindings/go/rsa/signing/v1alpha1/schemas/Config.schema.json",
  "title": "Config",
  "type": "object",
  "description": "Config defines configuration for signing based on AlgorithmRSASSAPSS or AlgorithmRSASSAPKCS1V15.",
  "properties": {
    "signatureAlgorithm": {
      "$ref": "#/$defs/ocm.software.open-component-model.bindings.go.rsa.signing.v1alpha1.SignatureAlgorithm"
    },
    "signatureEncodingPolicy": {
      "$ref": "#/$defs/ocm.software.open-component-model.bindings.go.rsa.signing.v1alpha1.SignatureEncodingPolicy"
    },
    "type": {
      "$ref": "#/$defs/ocm.software.open-component-model.bindings.go.runtime.Type",
      "description": "Type identifies this configuration object’s runtime type.",
      "oneOf": [
        {
          "const": "RSASigningConfiguration/v1alpha1"
        },
        {
          "deprecated": true,
          "const": "RSASigningConfiguration"
        }
      ]
    }
  },
  "required": [
    "type"
  ],
  "additionalProperties": false,
  "$defs": {
    "ocm.software.open-component-model.bindings.go.rsa.signing.v1alpha1.SignatureAlgorithm": {
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "$comment": "generated by the ocm schema generation tool",
      "$id": "ocm.software/open-component-model/bindings/go/rsa/signing/v1alpha1/schemas/SignatureAlgorithm.schema.json",
      "title": "SignatureAlgorithm",
      "type": "string",
      "description": "SignatureAlgorithm is the signature algorithm to use when creating new signatures.\nThis field is optional and defaults to AlgorithmRSASSAPSS. For verification, this field is ignored\nand the signature algorithm is inferred from the signature specification.",
      "oneOf": [
        {
          "description": "AlgorithmRSASSAPSS is the identifier for the RSA Probabilistic Signature Scheme (RSASSA-PSS).\n\nRSASSA-PSS is the recommended modern RSA signature algorithm, defined in:\n- PKCS #1 v2.1: https://datatracker.ietf.org/doc/html/rfc3447#section-8.1\n- NIST FIPS 186-4: https://csrc.nist.gov/publications/detail/fips/186/4/final\n\nKey properties:\n- Based on the RSA cryptosystem with probabilistic padding.\n- Uses a random salt and a mask generation function (MGF1, usually SHA-2).\n- Non-deterministic: the same message produces different signatures when signed multiple times.\n- Stronger theoretical security guarantees than the older deterministic RSASSA-PKCS1 v1.5 scheme.\n\nVerification flow:\n1. Apply the same padding function (with expected salt length and hash).\n2. Perform the RSA public key operation on the signature.\n3. Compare the result against the expected padded hash value.\n\nParameters used in OCM:\n- Hash function: SHA-256, SHA-384, or SHA-512 based on digest specification for the signing handler.\n- Salt length: equal to the length of the hash output.\n- MGF: MGF1 with the same underlying hash function, non modifiable.\n\nThis is the default algorithm for the new OCM Signature Libraries, but older version of OCM used\nRSASSA-PKCS1 v1.5 as default.",
          "const": "RSASSA-PSS"
        },
        {
          "description": "AlgorithmRSASSAPKCS1V15 is the identifier for the RSA signature scheme with PKCS #1 v1.5 padding.\n\nRSASSA-PKCS1 v1.5 is the legacy RSA signature algorithm, defined in:\n- PKCS #1 v1.5 and v2.2: https://datatracker.ietf.org/doc/html/rfc8017#section-8.2\n- NIST FIPS 186-4: https://csrc.nist.gov/publications/detail/fips/186/4/final\n\nKey properties:\n- Based on the RSA cryptosystem with deterministic padding.\n- Uses an ASN.1 DigestInfo structure containing the message digest.\n- Deterministic: the same message always produces the same signature with the same key.\n- Widely implemented and historically the default in many libraries and standards.\n- Considered less secure than RSASSA-PSS due to deterministic padding and a history of\npadding oracle attacks, but still accepted in many environments for backward compatibility.\n\nVerification flow:\n1. Perform the RSA public key operation on the signature.\n2. Compare the result against the expected ASN.1 DigestInfo structure of the message digest.\n\nParameters used in OCM:\n- Hash function: SHA-256, SHA-384, or SHA-512 based on digest specification for the signing handler.\n- Padding: fixed PKCS #1 v1.5 encoding (non-probabilistic, non-configurable).\n\nNotes:\n- RSASSA-PKCS1 v1.5 was the default algorithm in older versions of OCM.\n- For new signatures, RSASSA-PSS is recommended and is the default in the new OCM Signature Libraries.",
          "const": "RSASSA-PKCS1-V1_5"
        }
      ]
    },
    "ocm.software.open-component-model.bindings.go.rsa.signing.v1alpha1.SignatureEncodingPolicy": {
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "$comment": "generated by the ocm schema generation tool",
      "$id": "ocm.software/open-component-model/bindings/go/rsa/signing/v1alpha1/schemas/SignatureEncodingPolicy.schema.json",
      "title": "SignatureEncodingPolicy",
      "type": "string",
      "description": "SignatureEncodingPolicy defines how signatures are serialized and stored.\nDifferent policies trade off compactness, self-containment, and ease of verification.",
      "oneOf": [
        {
          "description": "SignatureEncodingPolicyPlain encodes the signature as a plain hex string.\n\nCharacteristics:\n- Most compact representation.\n- Not self-contained: verification requires the public key to be supplied\nfrom an external source (e.g. configuration, key management system).\n- No support for embedding or distributing certificate chains.",
          "const": "Plain"
        },
        {
          "description": "SignatureEncodingPolicyPEM encodes the signature in a PEM block, optionally\nfollowed by the signer’s certificate chain.\n\nEncoding procedure:\n1. Create a PEM block with type \"SIGNATURE\".\n2. Insert the raw signature bytes into the block.\n3. Add the signing algorithm (e.g. \"RSASSA-PSS\") as the \"Signature Algorithm\" header.\n4. Encode the block into PEM format.\n5. Optionally append the signer’s certificate chain in PEM format\n(only possible if the signature was created with a certificate).\n\nVerification rules:\n1. The public key may be extracted from an appended and validated certificate chain.\n2. The signature’s logical identity (its OCM signature name) must match the\nDistinguished Name (DN) of the trusted certificate used for verification.\n3. If no external public key is supplied, verification MUST use a validated\ncertificate chain bundled with the signature. Validation can rely on the host\nsystem’s trust store or on a distributed PKI root certificate.\n4. Every signature MUST be stored together with its certificate chain to ensure\nthat the trust path can be verified upon retrieval.\n\nNotes:\n- This is the default signature encoding policy.\n- Background: https://github.com/open-component-model/ocm/issues/584\n\nExperimental: This encoding policy is experimental and may change or be deprecated in the future.",
          "const": "PEM"
        }
      ]
    },
    "ocm.software.open-component-model.bindings.go.runtime.Type": {
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "$comment": "this core runtime schema was automatically included by the ocm schema generation tool to allow introspection",
      "$id": "ocm.software/open-component-model/bindings/go/runtime/schemas/Type.schema.json",
      "title": "Type",
      "type": "string",
      "description": "Type represents a structured type with an optional version and a name. It is used to identify the type of an object in a versioned API.",
      "pattern": "^([a-zA-Z0-9][a-zA-Z0-9.]*)(?:/(v[0-9]+(?:alpha[0-9]+|beta[0-9]+)?))?$"
    }
  }
}